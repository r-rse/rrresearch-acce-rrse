{
  "hash": "5504f0a5df854afbe578b7ae466f56d5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Controlling flow\"\n---\n\n\n## Control flow using logical statements\n\nOften when we're coding **we want to control the flow of our actions.** This can be done by setting **actions to occur only if a condition or a set of conditions are met**.\n\nThere are several ways you can control flow in R.\n\n**For conditional statements**, the most commonly used approaches is to use `if()` and `else` statements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if\nif (condition is true) {\n  perform action\n}\n\n# if ... else\nif (condition is true) {\n  perform action\n} else {  # that is, if the condition is false,\n  perform alternative action\n}\n```\n:::\n\n\nSay, for example, that we want R to print a different message depending on the value of variable `x`.\n\nWe could encode that with the following `if()` statement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 8 \n\nif (x >= 10) { # <1>\n  print(\"x is greater than or equal to 10\") # <2>\n} else {\n  print(\"x is less than 10\") # <3>\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is less than 10\"\n```\n\n\n:::\n:::\n\n\n1.  The condition to be met is that `x` is greater than or equal to 10.\n2.  If the condition is met, the message \"x is greater than or equal to 10\" is printed.\\\n3.  If the condition is not met, the message \"x is less than 10\" is printed.\n\n::: callout-caution\n**Important:** when R evaluates the condition inside `if()` statements, it is looking for a single logical value, i.e., `TRUE` or `FALSE`.\n\nThis can cause some headaches for beginners. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 8:10 \n\nif (x >= 10) { \n  print(\"x is greater than or equal to 10\") \n} else {\n  print(\"x is less than 10\") \n}\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in if (x >= 10) {: the condition has length > 1\n```\n\n\n:::\n:::\n\n\nThis produces an error because `x >= 10` is a vector of logical values, not a single logical value.\n:::\n\n## Combine multiple conditions\n\n### Use `&&` and `||`\n\nIf we want to combine multiple conditions in our `if` statements, we can use the `&&` and `||` operators.\n\nFor example, let's say we want to **print a message if `x` is greater than 10 and less than 20** and another if the condition is not met\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 11\n\nif (x > 10 && x < 20) {\n  print(\"x is greater than 10 and less than 20.\")\n} else {\n  print(\"x is not greater than 10 and less than 20.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is greater than 10 and less than 20.\"\n```\n\n\n:::\n:::\n\n\nThe `&&` operator combines the two conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx > 10 && x < 20\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nand returns `TRUE` because both conditions are met, printing the appropriate message.\n\nIf we change the value of `x` to 7, the message will change:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 7\n\nif (x > 10 && x < 20) {\n  print(\"x is greater than 10 and less than 20.\")\n} else {\n  print(\"x is not greater than 10 and less than 20.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is not greater than 10 and less than 20.\"\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n`&` and `|` are **vectorised**. This means that they can be used to compare vectors of logical values, and will return a vector of logical values.\n\n`&&` and `||` are scalar versions, and will only compare vectors of length 1. Because `if()` statements require a single logical value, you should use `&&` and `||` in `if()` statements.\n:::\n\n### Aggregate logical tests with `any()` and `all()`\n\nSometimes we might want to get an overall sense of whether a condition is met across a vector of values.\n\nWe can use the `any()` and `all()` functions to do this.\n\n-   The `any()` function will return **`TRUE` if at least one `TRUE` value** is found within a vector, otherwise it will return `FALSE`.\n\n-   The function `all()`, as the name suggests, will only return `TRUE` if all values in the vector are `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"apple\", \"banana\")\n\nany(x == \"banana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nall(x == \"banana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n## Switch between multiple alternatives\n\nLet's say we want to be able to calculate either the mean, median, or max of a vector `x` depending on the value of a variable called `type`.\n\nWe can use the `switch()` function to do this.\n\nThe `switch()` function is **used to select one of several alternatives based on the value of a single expression**. It is similar to a series of if-else statements but provides a more concise and readable way to handle multiple conditions.\n\n``` r\nswitch(EXPR, CASE1 = RESULT1, CASE2 = RESULT2, ..., DEFAULT)\n```\n\nThe most straight forward way to use the function is to provide a **single character string to the `EXPR` (the first) argument**, and then a **series of named arguments**, each of which is a possible value or expression to be executed.\n\n`switch()` then **matches the value of `EXPR` to name of an option and executes the code.**\n\nA **default value can be provided as the last unnamed argument**, which is executed if no match is found.\n\nLet's have a look at it in action:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(100, mean = 10, sd = 2) # <1>\n\ntype <- \"mean\" # <2>\n  switch(type, # <3>\n         mean = mean(x),\n         median = median(x),\n         max = max(x),\n         NA)\n\ntype <- \"max\" # <4>\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         max = max(x),\n         NA)\n\ntype <- \"random\" # <5>\n  switch(type,\n         mean = mean(x),\n         median = median(x),\n         max = max(x),\n         NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9.856017\n[1] 14.1711\n[1] NA\n```\n\n\n:::\n:::\n\n\n1.  We create a vector `x` of 100 random numbers with a mean of 10 and a standard deviation of 2.\n2.  We create a variable `type` and set it to `\"mean\"`.\n3.  We use `switch()` to calculate the mean, median, or max of `x` depending on the value of `type`. The first time we run it the mean is calculated.\n4.  We change the value of `type` to `\"max\"` and use `switch()` again. This time the max is calculated.\n5.  We change the value of `type` to `\"random\"` and use `switch()` again. This time the default `NA` is returned as there are no matches of the value of `type` to the named options.\n\n## Vectorised `if` statements\n\nAs we just saw, **`if`** statements are **designed to respond to a single logical condition**.\n\nTo be able to perform `if` `else` statements on vectors, we can use the built in `ifelse()` function.\n\n`ifelse()` function accepts both singular and vector inputs and is structured as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ifelse function\nifelse(condition is true, perform action, perform alternative action)\n```\n:::\n\n\nwhere:\n\n-    the first argument is the condition or a set of conditions to be met\n\n-    the second argument is the statement that is evaluated when the condition is `TRUE`, and\n\n-   the third statement is the statement that is evaluated when the condition is `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- -3\nifelse(y < 0, \"y is a negative number\", \"y is either positive or zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"y is a negative number\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- c(-3, 0, 3)\nifelse(y < 0, \"y is a negative number\", \"y is either positive or zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"y is a negative number\"       \"y is either positive or zero\"\n[3] \"y is either positive or zero\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}