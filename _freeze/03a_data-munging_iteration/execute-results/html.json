{
  "hash": "e9d4950790406533c3620f002ea2a0eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iteration\"\nsubtitle: \"Data Munging\"\n---\n\n\n\nLet's say **we want to repeat a process multiple times, iterating over a number of inputs**. In this case we want to load every file in `data-raw/wood-survey-data-master/individual/`. \n\nWe have a few options for how to approach this problem. In R there are two paradigms for iteration:\n\n- **imperative iterations**: (for and while loops)\n  - great place to start because they make iteration very explicit.\n  - quite verbose, and require quite a bit of bookkeeping code that is duplicated for every `for` loop.\n- **functional programming**: using functions to iterate over other functions.\n  - focus is on the operation being performed rather than the bookkeeping.\n  - can be more elegant and succinct.\n\n\n## Iterating using loops\n\n### Simple loop\n\nHere's an example of a simple loop. **During each iteration, it prints a message to the console, reporting the value of `i`.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  print(paste0(\"i is \", i))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"i is 1\"\n[1] \"i is 2\"\n[1] \"i is 3\"\n[1] \"i is 4\"\n[1] \"i is 5\"\n[1] \"i is 6\"\n[1] \"i is 7\"\n[1] \"i is 8\"\n[1] \"i is 9\"\n[1] \"i is 10\"\n```\n\n\n:::\n:::\n\n\nThe **loop iterates over the vector of values supplied in `1:10`, sequentially assigning a new value to variable `i` each iteration. `i` is therefore the varying input and everything else in the code stays the same during each iteration.**\n\n\n## Loops in practice\n\n### Reading in multiple files\n\n\n\n::: {.cell}\n\n:::\n\n\nLet's now **apply a loop to read in all 67 files at once**.\n\nWe have the file paths in our `individual_paths` vector. This is the input we want to iterate over.  We can use a **`for` loop**  to supply each path as the `file` argument in `readr::read_csv()`.\n\n### Storing loop outputs\n\nThe previous loop we saw didn't generate any new objects, it just printed output to the console. We, however, **need to store the output of each iteration (the tibble we've just read in)**. \n\nIt's **important for efficiency to allocate sufficient space in memory for the output before starting a `for` loop**.  Growing the `for` loop at each iteration, using `c()` for example, will be very slow.\n\nLet's **create an output vector to store the tibbles containing the read in data**. We want it to be a list because we'll be storing heterogeneous objects (tibbles) in each element.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindiv_df_list <- vector(\"list\", length(individual_paths))\n\nhead(indiv_df_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n\n[[5]]\nNULL\n\n[[6]]\nNULL\n```\n\n\n:::\n:::\n\n\nWe've **used the `length()` of the input to specify the size of our output list** so each path gets an output element.\n\n\n### Looping over indices\n\nNext, we **need a sequence of indices as long as the input vector (`individual_paths`)**. We can **use `seq_along()` to create our index vector**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(individual_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n[51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67\n```\n\n\n:::\n:::\n\n\nNow we're ready to write our `for` loop. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(individual_paths)) {\n  indiv_df_list[[i]] <- readr::read_csv(individual_paths[i], show_col_types = FALSE)\n}\n```\n:::\n\n\nAt each step of the iteration, the **file specified in the `i`th element of `individual_paths` vector is read in and assigned to th `i`th element of our output list.**\n\nWe're also **using the `show_col_types` argument to `read_csv()` to suppress the output of column types to the console.**\n\nWe can extract individual tibbles using `[[` sub-setting to inspect:\n\n::: {.cell}\n\n```{.r .cell-code}\nindiv_df_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 376 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 366 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\nindiv_df_list[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 714 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 fb75a8c… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 30a7c77… BART_046.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 789d030… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 0e4fb38… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 cb0e456… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 5fc5cf8… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 5d15faf… BART_046.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 d27a1bf… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 d5f9ab5… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 e52c3be… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 704 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\nWe can also inspect the contents of our output list interactively using `View()`\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](assets/view_indiv_list.png){width=818}\n:::\n:::\n\n\n\n### Looping over objects\n\nWe can also **loop over objects instead of indices**. \n\nIn this case, we'll **supply the paths themselves as the input to our loop and these will be passed as-is to `read_csv()`.** \n\nThis time we don't have our element indices to index the elements of the output list each tibble should be stored in. To get around this **we'll assign names** to each element and **index the output list by name**. \n\n**We can use the `basename` (actual file name) of each path as a name**, which I can get through `basename()` from each file path.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual_paths[1]\nbasename(individual_paths[1])\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n/cloud/project/data-raw/wood-survey-data-master/individual/NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T172340Z.csv\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T172340Z.csv\"\n```\n\n\n:::\n:::\n\n\nSo let's **tweak our output list to store the tibbles by name rather than index**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindiv_df_list <- vector(\"list\", length(individual_paths)) # <1>\nnames(indiv_df_list) <- basename(individual_paths) # <2>\n```\n:::\n\n1. We've created an output list of the same length as `individual_paths`.\n2. We've assigned the `basename` of each path as the name of each element in the output list. \n\nLet's have a look at the first few elements of our output list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(indiv_df_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T172340Z.csv`\nNULL\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T144119Z.csv`\nNULL\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-08.basic.20190806T143255Z.csv`\nNULL\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T143433Z.csv`\nNULL\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T144133Z.csv`\nNULL\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2017-07.basic.20190806T144111Z.csv`\nNULL\n```\n\n\n:::\n:::\n\n\nNow we can loop over the paths themselves:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (path in individual_paths) { # <1>\n  indiv_df_list[[basename(path)]] <- readr::read_csv(path, show_col_types = FALSE) # <2>\n}\n```\n:::\n\n\n1. We're looping over the paths themselves, rather than indices. Each path is assigned to the variable `path` during each iteration.\n2. We're assigning the tibble read in from each path to the element of the output list with the same name as the file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(indiv_df_list, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T172340Z.csv`\n# A tibble: 376 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 366 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n\n$`NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T144119Z.csv`\n# A tibble: 714 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 fb75a8c… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 30a7c77… BART_046.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 789d030… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 0e4fb38… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 cb0e456… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 5fc5cf8… BART_072.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 5d15faf… BART_046.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 d27a1bf… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 d5f9ab5… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 e52c3be… BART_036.bas… 2015-09-01 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 704 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\n\n### Collapsing our output list into a single tibble.\n\nNow we've got our list of tibbles, **we want to collapse or \"reduce\" our output list into a single tibble**. There are a number of ways to do this in R.\n\n#### Base R\n\nOne first approach we might think of is to use base function `rbind()`. This **takes any number of tibbles as arguments and binds them all together**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(indiv_df_list) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T172340Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T144119Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-08.basic.20190806T143255Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T143433Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T144133Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2017-07.basic.20190806T144111Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2017-08.basic.20190806T143426Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2017-09.basic.20190806T143740Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2018-08.basic.20190806T143026Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.BART.DP1.10098.001.vst_apparentindividual.2018-09.basic.20190806T144743Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T155155Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T155228Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2015-10.basic.20190806T160029Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2015-11.basic.20190806T155340Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2016-07.basic.20190806T154424Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2016-08.basic.20190806T155619Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T155751Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T154902Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2017-07.basic.20190806T161731Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2017-08.basic.20190806T155239Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2017-09.basic.20190806T154054Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2017-10.basic.20190806T154917Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2018-09.basic.20190806T154756Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D01.HARV.DP1.10098.001.vst_apparentindividual.2018-10.basic.20190904T080421Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T180623Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2015-10.basic.20190806T180501Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T180452Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2016-11.basic.20190806T162810Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2017-09.basic.20190806T180226Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2017-10.basic.20190806T162804Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2018-09.basic.20190806T162758Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D02.BLAN.DP1.10098.001.vst_apparentindividual.2018-11.basic.20190930T153245Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D03.DSNY.DP1.10098.001.vst_apparentindividual.2018-01.basic.20190806T170456Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D03.DSNY.DP1.10098.001.vst_apparentindividual.2018-05.basic.20190806T165614Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2015-08.basic.20190806T155333Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-02.basic.20190806T151351Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-03.basic.20190806T151416Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-04.basic.20190806T151437Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-05.basic.20190806T154733Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-06.basic.20190806T155301Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-07.basic.20190806T155324Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-08.basic.20190806T153300Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T151857Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T154351Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2016-11.basic.20190806T152215Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2017-03.basic.20190806T152514Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2017-04.basic.20190806T154915Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2017-12.basic.20190806T164409Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2018-01.basic.20190806T150606Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D04.GUAN.DP1.10098.001.vst_apparentindividual.2018-02.basic.20190806T150635Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2015-05.basic.20190806T151458Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2015-06.basic.20190806T151516Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T154811Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2016-11.basic.20190806T154932Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2017-10.basic.20190806T155315Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2017-11.basic.20190806T164155Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D07.GRSM.DP1.10098.001.vst_apparentindividual.2018-11.basic.20190930T154643Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2015-06.basic.20190806T173627Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2015-07.basic.20190806T165116Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T160924Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2016-09.basic.20190806T161107Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2016-10.basic.20190806T155600Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2017-10.basic.20190806T161504Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2017-11.basic.20190806T165044Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2018-10.basic.20190904T074322Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D08.DELA.DP1.10098.001.vst_apparentindividual.2018-11.basic.20190930T162311Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n              NEON.D09.DCFS.DP1.10098.001.vst_apparentindividual.2015-09.basic.20190806T161704Z.csv\nindiv_df_list spec_tbl_df,12                                                                       \n```\n\n\n:::\n:::\n\n\n\nHmm, that doesn't seem to have done what we want. That's because **`rbind` expects multiple tibbles** as inputs and we're giving it a single list. We somehow **want to extract the contents of each element of `indiv_df_list` and pass them all to `rbind`**.\n\nFor this we can **use `do.call`**.`do.call` takes a **function or the name of a function we want to execute as it's first argument**, `what`. The **second argument** of `do.call`, `args` is a **list** of arguments we want to pass to the function specified in `what`. When `do.call` is executed, it extracts the elements of `args` and passes them as arguments to `what`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(what = \"rbind\", args = indiv_df_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n * <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\nSuccess!\n\n\n#### Tidyverse\n\nThere are also ways to do this using the tidyverse.\n\n**`purrr::reduce`**\n\n**`reduce` from package `purrr` combines the elements of a vector or list into a single object according to the function supplied to `.f`.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::reduce(indiv_df_list, .f = rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\n**`dplyr::bind_rows`**\n\n`bind_rows` offers a shortcut to reducing a list of tibbles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::bind_rows(indiv_df_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\n\n## Functional iteration\n\n**Loops are an important basic concept in programming**. However another approach available in R is **functional programming which iterates a function or pipe of functions over given input(s)**. We've actually just been using functional programming with `do.call` and `reduce`.\n\nThis idea of **passing a function to another function** is one of the **behaviours that makes R a functional programming** language and is **extremely powerful**. \n\nIt allows us to:\n\n1. **use functions rather than `for` loops to perform iteration** over other functions.\n1. wrap the **code we want to iterate over in custom functions**.\n\nThis in turn allows us to replace many `for` loops with code that is both more succinct and easier to read. \n\n\nIn **base R** there is the **family of `*apply` functions (`lapply`, `vapply`, `sapply`, `apply`, `mapply`) to perform functional iteration**. These are handy to know if you want to write workflows or software that are low on dependencies. However, I prefer using the functions in tidyverse package `purrr`.\n\n### Iterating using `purrr`\n\nIn the tidyverse such functionality is provided by **package [`purrr`](https://purrr.tidyverse.org/)**, which provides a **complete and consistent set of tools for working with functions and vectors of inputs**. I prefer it to the apply family because it has a **more consistent API**, a **more intuitive syntax** and **functions that return vectors of a specific data type**.\n\nThe first thing we might try is to replace our `for` loop with a function.\n\n#### `map`\n\nThe **basic `purrr` function is `map()`** and it **allows us to pass the elements of an input vector or list to a single argument of a function we want to repeat**. \n\nIt **always returns a list, one element for each element of the input vector**, and is useful for iterating over functions that return more complicated objects like tibbles, vectors or lists, instead of single values.\n\nIt also has a **handy shorthand for specifying the argument to pass the input object to**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual <- purrr::map(\n  individual_paths, # <1>\n  ~ readr::read_csv(file = .x, show_col_types = FALSE) # <2>\n) |>\n  purrr::list_rbind() # <3>\n```\n:::\n\n\n1. The first argument to `map` is the input vector of paths we want to iterate over. \n2. The next argument is a formula specifying the function we want to repeat as well as which argument the input is passed to. Here we're saying that we want to repeatedly run `read_csv` and we indicate the argument we want the input passed to (`file`) by `.x`. Note as well the `~` notation before the function definition which is shorthand for `.f = `.\n3. Finally we use `list_rbind` from `purrr` package, which is equivalent to `bind_rows`, to collapse the output list into a single tibble.\n\n\n#### Some tips on efficiency\n\nWhile the above code is elegant, it **might not be the most efficient**. `read_csv` **calls `readr` function `type_convert()` to determine the data type for each column** when it reads a file in, which is relatively expensive. \n\nThe elegant code above mean that **`type_convert()` is for every file that is loaded, ie 67 times**.\n\nA **more efficient way** of implementing this is to **set all columns as character on-read** and then **run `type_convert` ourselves, only once**, and only **after our data have been combined into a single tibble**.\n\nWe can **set all columns to character by default by providing column formatting function `readr::cols(.default = \"c\"))` as the `read_csv` `col_types` argument**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual <- purrr::map(\n  individual_paths,\n  ~ readr::read_csv(.x,\n    col_types = readr::cols(.default = \"c\"),\n    show_col_types = FALSE\n  )\n) %>%\n  purrr::list_rbind() %>%\n  readr::type_convert()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 12\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 4 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>\n```\n\n\n:::\n:::\n\n\n\nThis might come in handy if you are dealing with a huge number of data files.\n\nOther packages to be aware of, **especially if you are dealing with very large tables, are [`data.table`](https://rdatatable.gitlab.io/data.table/)** or, if you don't need to read in the entire dataset into memory, have a look at the `arrow` package and specifically [**opening entire folders of files as arrow datasets**](https://arrow.apache.org/docs/r/reference/open_dataset.html). \n\n\n##### Simple benchmark\n\nA simple benchmark of the different methods of reading in and combining data from multiple files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\n  map = {\n    # tidyverse\n    purrr::map(\n      individual_paths,\n      ~ readr::read_csv(.x,\n        show_col_types = FALSE\n      )\n    ) %>%\n      purrr::list_rbind()\n  },\n  # tidyverse + read in as character\n  map_type_convert = {\n    purrr::map(\n      individual_paths,\n      ~ readr::read_csv(.x,\n        col_types = readr::cols(.default = \"c\"),\n        show_col_types = FALSE\n      )\n    ) %>%\n      purrr::list_rbind() %>%\n      readr::type_convert()\n  },\n  # data.table\n  data_table = {\n    lapply(individual_paths, data.table::fread, sep = \",\") %>%\n      do.call(\"rbind\", .)\n  },\n  # purrr + data.table\n  data_table_map = {\n    purrr::map(individual_paths, data.table::fread, sep = \",\") %>%\n      purrr::list_rbind()\n  },\n  times = 20\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark::microbenchmark(map = {: less accurate nanosecond\ntimes to avoid potential integer overflows\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n             expr       min        lq      mean    median        uq       max\n              map 182.67169 184.80108 192.44211 187.29374 191.62047 248.44963\n map_type_convert 145.84270 149.28518 154.51144 154.75427 157.09105 172.51668\n       data_table  26.21196  26.76560  33.55172  29.75183  29.95241  81.07340\n   data_table_map  42.06727  45.14973  47.66774  47.70159  50.18174  52.64568\n neval\n    20\n    20\n    20\n    20\n```\n\n\n:::\n:::\n\n\n## Writing out our tibble to disk\n\nRemember the other two files included in our raw data, `vst_mappingandtagging.csv`, and `vst_perplotperyear.csv`? Well the truth is they also came in multiple files which I put together in pretty much the same way as you just did!\n\nSo for posterity, **let's save this file out too**. This **isn't our finished analytic data set**, we still have some processing to do. So let's **just save it at `raw_data_path`, along with the other files.**\n\nTo write out a csv file we use `readr::write_csv()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  readr::write_csv(file = fs::path(raw_data_path, \"vst_individuals.csv\"))\n```\n:::\n\n\n\n\n## Update `individual.R`\n\nEverything looks good. Before moving on, let's **update our `individual.R` script with the additional code we've just written for reading in, combining and writing out the combined individual data**.\n\nAdd the following code and comments to `individual.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in all individual tables into one\nindividual <- purrr::map(\n  individual_paths,\n  ~ readr::read_csv(\n    file = .x,\n    col_types = readr::cols(.default = \"c\"),\n    show_col_types = FALSE\n  )\n) %>%\n  purrr::list_rbind() %>%\n  readr::type_convert()\n\nindividual %>%\n  readr::write_csv(file = fs::path(raw_data_path, \"vst_individuals.csv\"))\n```\n:::\n\n\n\n\n***\n\nLearn more about iteration and the family of `purrr` functions in the [iteration chapter](https://r4ds.had.co.nz/iteration.html) in R for data science\n\n\n::: {.cell}\n<iframe src=\"assets/cheatsheets/purrr.pdf\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n::: {.cell}\n<iframe src=\"assets/cheatsheets/datatable.pdf\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n\nLearn more about [perfomance and efficency](http://adv-r.had.co.nz/Performance.html) in general. \n",
    "supporting": [
      "03a_data-munging_iteration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}