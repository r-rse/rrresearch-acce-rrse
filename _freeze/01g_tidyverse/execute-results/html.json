{
  "hash": "b79840e8a2f489acb4a7214dbdb6b80f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to the tidyverse\"\nsubtitle: \"The tidyverse way\"\n---\n\n\n## Intro to the tidyverse\n\n::: {.alert .alert-info}\nThe [Tidyverse](https://www.tidyverse.org/) is a coherent system of packages for data manipulation, exploration and visualization that share a common design philosophy.\n\n### Advantages of the tidyverse\n\n-   Consistent functions.\n-   Workflow coverage.\n-   A parsimonious approach to the development of data science tools.\n:::\n\n\n![](assets/tidyverse_copy.png)\n\n![](assets/tidyverse-workflow.png)\n\n### Tidyverse Principles\n\n-   `tibbles` as main data structures.\n-   Tidy data where rows are single observations and columns the variables observed.\n-   Piping the outputs of tidyverse functions as inputs to subsequent functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"tibble\", \"dplyr\"))\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## `tibbles`\n\n> `tibbles` are one of the unifying features of the tidyverse, and are the tidyverse version of a data.frame (I will use them interchangeably in the rest of the text).\n\n### Features\n\n-   Better printing behaviour.\n-   Never coerces characters to factors.\n-   More robust error handling.\n\n### Creating tibbles\n\n#### Coercing data.frames\n\nYou can coerce a data.frame to a tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_tbl <- tibble::as_tibble(trees)\ntree_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 31 × 3\n   Girth Height Volume\n   <dbl>  <dbl>  <dbl>\n 1   8.3     70   10.3\n 2   8.6     65   10.3\n 3   8.8     63   10.2\n 4  10.5     72   16.4\n 5  10.7     81   18.8\n 6  10.8     83   19.7\n 7  11       66   15.6\n 8  11       75   18.2\n 9  11.1     80   22.6\n10  11.2     75   19.9\n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\n\nAs you can see, printing tibbles is much tidier and informative and designed so that you don’t accidentally overwhelm your console when you print large data.frames.\n\n#### Creating new tibbles\n\nYou can create a new tibble from individual vectors with `tibble()`. `tibble()` will automatically recycle inputs of length 1, and allows you to refer to variables that you just created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::tibble(\n    x = 1:5, \n    y = 1, \n    z = x ^ 2 + y\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n      x     y     z\n  <int> <dbl> <dbl>\n1     1     1     2\n2     2     1     5\n3     3     1    10\n4     4     1    17\n5     5     1    26\n```\n\n\n:::\n:::\n\n\n## Subsetting tibbles\n\n### Base R subsetting\n\nWe can use all the tools we learnt to subset data.frames to subset tibbles.\n\n### Subsetting using the tidyverse\n\nYou can also subset `tibbles` using tidyverse functions from package `dplyr`. `dplyr` verbs are inspired by SQL vocabulary and designed to be more intuitive.\n\nLet's load `dplyr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\nThe first argument of the main `dplyr` functions is a `tibble` (or data.frame)\n\n#### Filtering rows with `filter()`\n\n`filter()` allows us to subset observations (rows) based on their values. The first argument is the name of the data frame. The **second and subsequent arguments are the expressions that filter the data frame.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(tree_tbl, Girth > 14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   Girth Height Volume\n   <dbl>  <dbl>  <dbl>\n 1  14.2     80   31.7\n 2  14.5     74   36.3\n 3  16       72   38.3\n 4  16.3     77   42.6\n 5  17.3     81   55.4\n 6  17.5     82   55.7\n 7  17.9     80   58.3\n 8  18       80   51.5\n 9  18       80   51  \n10  20.6     87   77  \n```\n\n\n:::\n:::\n\n\n`dplyr` executes the filtering operation by generating a logical vector and returns a new `tibble` of the rows that match the filtering conditions. You can therefore use any logical operators we learnt using `[`.\n\nNote as well that using `dplyr` allows us to use bare column names, making conditional statements much more clear and concise.\n\n#### Slicing rows with `slice()`\n\nUsing `slice()` is similar to subsetting using element indices in that we provide element indices to select rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(tree_tbl, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  Girth Height Volume\n  <dbl>  <dbl>  <dbl>\n1   8.6     65   10.3\n```\n\n\n:::\n\n```{.r .cell-code}\nslice(tree_tbl, 2:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  Girth Height Volume\n  <dbl>  <dbl>  <dbl>\n1   8.6     65   10.3\n2   8.8     63   10.2\n3  10.5     72   16.4\n4  10.7     81   18.8\n```\n\n\n:::\n:::\n\n\n#### Selecting columns with `select()`\n\n`select()` allows us to subset columns in tibbles using operations based on the names of the variables.\n\nIn `dplyr` we use **unquoted column names** (ie `Volume` rather than `\"Volume\"`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tree_tbl, Height, Volume)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 31 × 2\n   Height Volume\n    <dbl>  <dbl>\n 1     70   10.3\n 2     65   10.3\n 3     63   10.2\n 4     72   16.4\n 5     81   18.8\n 6     83   19.7\n 7     66   15.6\n 8     75   18.2\n 9     80   22.6\n10     75   19.9\n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\n\nBehind the scenes, `select` matches any variable arguments to column names creating a vector of column indices. This is then used to subset the `tibble`.\n\nAs such we can create ranges of variables using their names and `:`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tree_tbl, Height:Volume)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 31 × 2\n   Height Volume\n    <dbl>  <dbl>\n 1     70   10.3\n 2     65   10.3\n 3     63   10.2\n 4     72   16.4\n 5     81   18.8\n 6     83   19.7\n 7     66   15.6\n 8     75   18.2\n 9     80   22.6\n10     75   19.9\n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\n\nThere's also a number of helper functions to make selections easier. For example, we can use `one_of()` to provide a character vector of column names to select.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(tree_tbl, one_of(c(\"Height\", \"Volume\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 31 × 2\n   Height Volume\n    <dbl>  <dbl>\n 1     70   10.3\n 2     65   10.3\n 3     63   10.2\n 4     72   16.4\n 5     81   18.8\n 6     83   19.7\n 7     66   15.6\n 8     75   18.2\n 9     80   22.6\n10     75   19.9\n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\n\n[Find out more about `dplyr` helper functions](https://tidyselect.r-lib.org/reference/select_helpers.html)\n\n## The pipe operator `%>%`\n\n> **Pipes** are a powerful tool for **clearly expressing a sequence of multiple operations.**\n\n> They help us write code in a way that is **easier to read and understand**. They also **remove the need for creating intermediate objects**.\n\n::: {alert=\"\" alert-info=\"\"}\nPipes take the output of the evaluation of the preceeding code and pipe it as the first argument to the subsequent expression.\n:::\n\nSuppose we want to get the first two rows and only columns `Girth` and `Volume`. We can chain the two operations together using the pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_tbl %>%\n    select(Girth, Volume) %>%\n    slice(1:2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  Girth Volume\n  <dbl>  <dbl>\n1   8.3   10.3\n2   8.6   10.3\n```\n\n\n:::\n:::\n\n\nThis form is very understandable because it focuses on intuitive verbs, not nouns. You can read this series of function compositions like it’s a set of imperative actions.\n\nAs mentioned, the **default behaviour** of the pipe is to pipe objects through **as the first argument** of the next expression. However, we can **pipe the object into a different argument using the `.` operator**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree_tbl %>%\n    lm(Girth ~ Height, data = .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Girth ~ Height, data = .)\n\nCoefficients:\n(Intercept)       Height  \n    -6.1884       0.2557  \n```\n\n\n:::\n:::\n\n\n*Note: The pipe, `%>%`, comes from the `magrittr` package by Stefan Milton Bache. Packages in the tidyverse load `%>%` for you automatically, so you don’t usually load `magrittr` explicitly.*\n\n\n## The base R pipe operator\n\n**Up until R version 4.1.0, the only pipe operator available was the `magrittr` pipe `%>%`,** hence I've introduced the pipe as part of the tidyverse section.\n\nHowever, **as of R version 4.1.0 a native base R pipe operator was introduced, `|>`** which is equivalent to the `magrittr` pipe `%>%` and is available without loading any packages!\n\n::: callout-tip\nOne difference between the **base R pipe operator `|>`** and `%>%` is that it is **not designed to work with functions that take the piped argument as anything but the first argument** so it is not as flexible as `%>%`.\n:::\n\n\n## Data Transformation with `dplyr` Cheat Sheet\n\n\n::: {.cell}\n<iframe src=\"assets/cheatsheets/data-transformation.pdf\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n",
    "supporting": [
      "01g_tidyverse_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}