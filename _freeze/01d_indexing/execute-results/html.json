{
  "hash": "fe18c3201cdaeca1ec0611ef45cd4dee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Indexing and subsetting\"\n---\n\n\n> R has many powerful subset operators. Mastering them will allow you to easily perform complex operations on any kind of dataset.\n\nThere are **many different ways** we can subset any kind of object, and **three different subsetting operators** for different data structures.\n\n## Subsetting vectors\n\nLet's start by examining subsetting in the simplest data structure, the vector.\n\n> Subsetting a vector always returns another vector.\n\nFirst let's create a vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 4:7\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6 7\n```\n\n\n:::\n:::\n\n\n### Subsetting using `[` and element indices\n\n#### Extracting single elements\n\nTo extract elements of a vector we can use the **square bracket operator** (`[`) and the **target element index**, **starting from one** (as R is a 1 indexed language):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\nIt may look different, but the square brackets operator is a function and means ***\"get me the nth element\".***\n\nIf we ask for an index beyond the length of the vector, R will return a missing value (`NA`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nIf we ask for the 0th element, we get an empty vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ninteger(0)\n```\n\n\n:::\n:::\n\n\n#### Extracting multiple elements\n\nWe can also ask for **multiple elements** at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6\n```\n\n\n:::\n:::\n\n\nOr **slices of the vector**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7\n```\n\n\n:::\n:::\n\n\nWe can ask for **the same element multiple times**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(1,1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 4 6\n```\n\n\n:::\n:::\n\n\n#### Excluding and removing elements\n\nIf we use a **negative number as the index of a vector**, R will return every element ***except*** for the one specified:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6 7\n```\n\n\n:::\n:::\n\n\nWe can **skip multiple elements**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1, -5)]  # or x[-c(1,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7\n```\n\n\n:::\n:::\n\n\n::: {.alert .alert-warning}\nIn general, be aware that the result of subsetting using indices could change if the vector is reordered.\n:::\n\n### Subsetting using element names\n\nIf the vector has a name attribute, we **can subset the vector more precisely using the element's name.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x) <- c(\"a\", \"b\", \"c\", \"d\")\n\nx[c(\"a\", \"c\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na c \n4 6 \n```\n\n\n:::\n:::\n\n\n::: {.alert .alert-success}\nSubsetting using names is the most robust way to extract elements. The position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!\n:::\n\n### Subsetting using logical vectors\n\nWe can also **use any logical vector** to subset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(FALSE, FALSE, TRUE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc d \n6 7 \n```\n\n\n:::\n:::\n\n\nSince comparison operators (e.g. `>`, `<`, `==`) evaluate to logical vectors, we can also use them to succinctly subset vectors: the following statement gives the same result as the previous one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc d \n6 7 \n```\n\n\n:::\n:::\n\n\nBreaking it down, this statement first evaluates `x > 5`, generating a logical vector `c(FALSE, FALSE, TRUE, TRUE)`, and then selects the elements of `x` corresponding to the `TRUE` values.\n\nWe can use `==` to mimic the previous method of indexing by name (remember you have to use `==` rather than `=` for comparisons):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[names(x) == \"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na \n4 \n```\n\n\n:::\n:::\n\n\n::: {.alert .alert-warning}\nAvoid using `==` to compare numbers unless they are integers! See [function `dplyr::near()`](https://dplyr.tidyverse.org/reference/near.html) instead.\n:::\n\nWe also might want to **subset using a vector of potential values**, that might not necessarily have matches in `x`.\n\nIn this case we can use `%in%`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[names(x) %in% c(\"a\", \"c\", \"e\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na c \n4 6 \n```\n\n\n:::\n:::\n\n\n#### Excluding named elements\n\nExcluding or removing named elements is a little harder.\n\nIf we try to skip one named element by negating the string, R complains (slightly obscurely) that it doesn't know how to take the negative of a string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-\"a\"]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in -\"a\": invalid argument to unary operator\n```\n\n\n:::\n:::\n\n\nHowever, we can use the `!=` (not-equals) operator to construct a logical vector that will do what we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[names(x) != \"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb c d \n5 6 7 \n```\n\n\n:::\n:::\n\n\nExcluding multiple named indices requires a different tactic through.\n\nTo perform such a subset robustly, we need to combine `%in%` and `!`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[!names(x) %in% c(\"a\",\"c\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb d \n5 7 \n```\n\n\n:::\n:::\n\n\nThis checks whether names of `x` take any value of the values in `c(\"a\",\"c\")`, returning the elements where the condition is `TRUE`. The `!` then negates the selection, returning only the elements whose names are not contained in `c(\"a\",\"c\")`.\n\n## Matrix subsetting\n\n> As matrices are just 2d vectors, all the subsetting operations using the `[` can also be applied to matrices.\n\n### Subsetting using element indices\n\nLet's create a matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:12, ncol=4, nrow=3)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n:::\n\n\n::: {.alert .alert-info}\nIndexing matrices with `[` takes two arguments: **the first expression is applied to the rows, the second to the columns:**\n:::\n\nSay we want the **2 and 3rd rows** of the **last and first column** (in that order) of our matrix. We can use all the subsetting we learned for vectors and apply them to each dimension of our matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2:3, c(4,1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   11    2\n[2,]   12    3\n```\n\n\n:::\n:::\n\n\n#### Subsetting whole rows or columns\n\nWe can leave the first or second arguments blank to retrieve all the rows or columns respectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[, c(2,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    4    7\n[2,]    5    8\n[3,]    6    9\n```\n\n\n:::\n\n```{.r .cell-code}\nm[c(2,3),]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    5    8   11\n[2,]    3    6    9   12\n```\n\n\n:::\n:::\n\n\nIf we only access one row or column, R will automatically convert the result to a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6  9 12\n```\n\n\n:::\n:::\n\n\nIf we want to keep the output as a matrix, we need to specify a *third* argument; `drop = FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[3, , drop=FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    3    6    9   12\n```\n\n\n:::\n:::\n\n\n::: {.alert .alert-info}\nTip: Higher dimensional arrays\n\nWhen dealing with multi-dimensional arrays, each argument to `[` corresponds to a dimension. For example, a 3D array, the first three arguments correspond to the rows, columns, and depth dimension.\n:::\n\n## Subsetting lists\n\n> There are three functions used to subset lists and extract individual elements: `[`, `[[`, and `$`.\n\n### Subsetting list elements\n\nUsing `[` will always return a list. If you want to *subset* a list, but not *extract* an element, then you will likely use `[`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist <- list(a = \"ACCE DTP Course\", b = 1:10, data = head(iris))\n```\n:::\n\n\n#### Subsetting by element indices\n\nAs with vectors, we can use element indices and `[` to subset lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] \"ACCE DTP Course\"\n```\n\n\n:::\n:::\n\n\nThis returns a *list with one element*.\n\nWe can use multiple indices to subset multiple list elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] \"ACCE DTP Course\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n#### Subsetting by name\n\nWe can also use names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[c(\"a\", \"b\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] \"ACCE DTP Course\"\n\n$b\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\nUsing a single `[` accesses the list as if it were a vector and returns a list.\n\n**Comparison operations involving the contents of list elements however won't work as they are not accessible at the level of `[` indexing.**\n\n### Extracting individual elements\n\n> **Extracting individual elements allow us to access the objects contained in a list**, which can be any type of object. Hence the result depends on the object each element contains.\n\nTo extract individual elements of a list, we use the **double-square bracket function: `[[`.**\n\n#### Extracting by element index\n\nAgain we can use element indices to extract the object contained in an element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\nNotice that now the result is a vector, not a list, which is what the second element contained.\n\nYou can't extract more than one element at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[[1:2]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in xlist[[1:2]]: subscript out of bounds\n```\n\n\n:::\n:::\n\n\nNor use it to skip elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[[-1]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in xlist[[-1]]: invalid negative subscript in get1index <real>\n```\n\n\n:::\n:::\n\n\n#### Extracting by element name\n\nWe can however use single names to extract elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ACCE DTP Course\"\n```\n\n\n:::\n:::\n\n\n##### The `$` operator\n\nThe `$` operator is a shorthand way for extracting single elements by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist$data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n##### List subsetting challenge {#chlg-list-subset}\n\nGiven the following list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist <- list(a = \"ACCE DTP Course\", b = 1:10, data = head(iris))\n```\n:::\n\n\nand using your knowledge of both list and vector subsetting, extract the number 2 from xlist.\n\n*Hint: the number 2 is contained within the \"b\" item in the list.*\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\" collapse=true}\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlist <- list(a = \"ACCE DTP Course\", b = 1:10, data = head(iris))\n\nxlist$b[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n:::\n\n## Subsetting data.frames\n\n> Data frames are **lists underneath the hood**, so similar subsetting rules apply. However they are **also two dimensional objects**.\n\n### Subsetting data.frames as a list\n\n#### Using `[` to subset\n\nUsing the **`[` operator with one argument** will act the same way as for lists, where each list element corresponds to a column. The resulting object will be a data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Girth\n1    8.3\n2    8.6\n3    8.8\n4   10.5\n5   10.7\n6   10.8\n7   11.0\n8   11.0\n9   11.1\n10  11.2\n11  11.3\n12  11.4\n13  11.4\n14  11.7\n15  12.0\n16  12.9\n17  12.9\n18  13.3\n19  13.7\n20  13.8\n21  14.0\n22  14.2\n23  14.5\n24  16.0\n25  16.3\n26  17.3\n27  17.5\n28  17.9\n29  18.0\n30  18.0\n31  20.6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[\"Girth\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Girth\n1    8.3\n2    8.6\n3    8.8\n4   10.5\n5   10.7\n6   10.8\n7   11.0\n8   11.0\n9   11.1\n10  11.2\n11  11.3\n12  11.4\n13  11.4\n14  11.7\n15  12.0\n16  12.9\n17  12.9\n18  13.3\n19  13.7\n20  13.8\n21  14.0\n22  14.2\n23  14.5\n24  16.0\n25  16.3\n26  17.3\n27  17.5\n28  17.9\n29  18.0\n30  18.0\n31  20.6\n```\n\n\n:::\n:::\n\n\n#### Using `[[` to extract\n\nSimilarly, `[[` will act to extract *a single column* as a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  8.3  8.6  8.8 10.5 10.7 10.8 11.0 11.0 11.1 11.2 11.3 11.4 11.4 11.7 12.0\n[16] 12.9 12.9 13.3 13.7 13.8 14.0 14.2 14.5 16.0 16.3 17.3 17.5 17.9 18.0 18.0\n[31] 20.6\n```\n\n\n:::\n\n```{.r .cell-code}\ntrees[[\"Girth\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  8.3  8.6  8.8 10.5 10.7 10.8 11.0 11.0 11.1 11.2 11.3 11.4 11.4 11.7 12.0\n[16] 12.9 12.9 13.3 13.7 13.8 14.0 14.2 14.5 16.0 16.3 17.3 17.5 17.9 18.0 18.0\n[31] 20.6\n```\n\n\n:::\n:::\n\n\nAnd `$` provides a convenient shorthand to extract columns by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees$Girth\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  8.3  8.6  8.8 10.5 10.7 10.8 11.0 11.0 11.1 11.2 11.3 11.4 11.4 11.7 12.0\n[16] 12.9 12.9 13.3 13.7 13.8 14.0 14.2 14.5 16.0 16.3 17.3 17.5 17.9 18.0 18.0\n[31] 20.6\n```\n\n\n:::\n:::\n\n\n### Subsetting data.frames as a matrix\n\nWith two arguments, `[` behaves the same way as for matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[1:5, c(\"Girth\", \"Volume\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Girth Volume\n1   8.3   10.3\n2   8.6   10.3\n3   8.8   10.2\n4  10.5   16.4\n5  10.7   18.8\n```\n\n\n:::\n:::\n\n\nIf we subset a single row, the result will be a data.frame (because the elements are mixed types):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Girth Height Volume\n3   8.8     63   10.2\n```\n\n\n:::\n:::\n\n\nBut for a single column the result will be a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[, \"Girth\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  8.3  8.6  8.8 10.5 10.7 10.8 11.0 11.0 11.1 11.2 11.3 11.4 11.4 11.7 12.0\n[16] 12.9 12.9 13.3 13.7 13.8 14.0 14.2 14.5 16.0 16.3 17.3 17.5 17.9 18.0 18.0\n[31] 20.6\n```\n\n\n:::\n:::\n\n\nThis can be changed with the third argument, `drop = FALSE`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees[, \"Girth\", drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Girth\n1    8.3\n2    8.6\n3    8.8\n4   10.5\n5   10.7\n6   10.8\n7   11.0\n8   11.0\n9   11.1\n10  11.2\n11  11.3\n12  11.4\n13  11.4\n14  11.7\n15  12.0\n16  12.9\n17  12.9\n18  13.3\n19  13.7\n20  13.8\n21  14.0\n22  14.2\n23  14.5\n24  16.0\n25  16.3\n26  17.3\n27  17.5\n28  17.9\n29  18.0\n30  18.0\n31  20.6\n```\n\n\n:::\n:::\n\n\n## Advanced R Cheat Sheet\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](assets/cheatsheets/advancedR.pdf)\n:::\n:::\n",
    "supporting": [
      "01d_indexing_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}