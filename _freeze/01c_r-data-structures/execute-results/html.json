{
  "hash": "f7c0fd46a9285fc96a5306c36ca3088d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data types, structures and classes\"\n---\n\n\n## Base types\n\n> Every object has a base type. Overall there are 25 different base object types that forms the core of the R language.\n\n## Base data types\n\nBase **data types** form the building blocks of all data structures and objects in R.\n\n> There are **5 base data types: `double`, `integer`, `complex`, `logical`, `character`** as well as `NULL`.\n\nNo matter how complicated your analyses become, all data in R is interpreted as one of these basic data types.\n\nYou can inspect the type of a value or object through function `typeof()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3.14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(\"banana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n:::\n\n\n::: callout-note\n## `NA` values\n\nIn R, NA stands for \"Not Available\" and is used to represent missing or undefined values. It serves as a placeholder to indicate that a value is not present or cannot be determined for a particular observation in a dataset.\n\nThere are different types of `NA` in R, including `NA_integer_`, `NA_real_`, `NA_complex_`, `NA_character_`, and `NA_logical_`, corresponding to different data types. These are used to represent missing values in specific data types. The default `NA` data type is `logical`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(NA_character_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n:::\n\n## Data Structures\n\n### Arrays and type coercion\n\n> The distinguishing feature of arrays is that all values are of the same data type.\n\nArrays can take values of any base data type and span any number of dimensions. However, **all values must be of the same base data type**. This allows for efficient calculation and matrix mathematics. The strictness also has some really important consequences which introduces another key concept in R, that of **type coercion**.\n\n### Vectors and Type Coercion\n\n#### Vectors\n\n> Vectors are one dimensional arrays.\n\nTo better understand the importance of data types and coercion, let's meet a special case of an array, the **vector**.\n\nOne way to create a new vector is to use function `vector()`. You can specify the length of the vector with argument `length` and the base data type through argument `mode`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- vector(length = 3)\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nA vector in R is essentially an ordered collection of things, with the special condition that *everything in the vector must be the same basic data type*.\n\nIf you don't choose the datatype, it'll default to `logical`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\nOtherwise, you can declare an empty vector of whatever type you like using argument `mode`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanother_vector <- vector(mode = \"character\", length = 3)\nanother_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\" \"\" \"\"\n```\n\n\n:::\n:::\n\n\nYou can also create a vector of **a series of numbers:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(1, 10, by = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3  2.4\n[16]  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9\n[31]  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1  5.2  5.3  5.4\n[46]  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9\n[61]  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.0  8.1  8.2  8.3  8.4\n[76]  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9\n[91] 10.0\n```\n\n\n:::\n:::\n\n\nYou can also create vectors by **combining individual elements using function `c`** (for combine).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, 6, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 6 3\n```\n\n\n:::\n:::\n\n\n### Type coercion\n\nQ: Given what we've learned so far, what do you think the following will produce?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, 6, \"3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\" \"6\" \"3\"\n```\n\n\n:::\n:::\n\n\nThis is something called ***type coercion***, and it is the **source of many surprises** and the reason why we need to be aware of the basic data types and how R will interpret them.\n\nWhen R encounters a mix of types (here numeric and character) to be combined into a single vector, it will force them all to be the same type.\n\n**Not all types can be coerced into another**, rather, **R has a coercion hierarchy rule**. All values are converted to the lowest data type in the hierarchy.\n\n::: {.alert .alert-success}\n##### R coercion rules:\n\n**`logical` -\\> `integer` -\\> `numeric` -\\> `complex` -\\> `character`**\n\n*where `->` can be read as \"are transformed into\".*\n:::\n\nIn our case, our `2`, & `6` integer values where converted to character.\n\nSome other examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"a\", TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"    \"TRUE\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"FALSE\", TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"FALSE\" \"TRUE\" \n```\n\n\n:::\n\n```{.r .cell-code}\nc(0, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n:::\n\n\nYou can try to force coercion against this flow using the `as.` functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchars <- c(\"0\", \"2\", \"4\")\nas.numeric(chars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(chars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(as.numeric(chars))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(c(0, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(c(\"FALSE\", TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"FALSE\", TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(as.logical(c(\"FALSE\", TRUE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n:::\n\n\nAs you can see, some surprising things can happen when R forces one basic data type into another!\n\n**If your data isn't the data type you expected, type coercion may well be to blame;** make sure everything is the same type in your vectors and your columns of data.frames, or you will get nasty surprises!\n\n#### Inspecting vectors\n\nWe can ask a few questions about vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsequence_example <- seq(10)\n\nhead(sequence_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(sequence_example, n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(sequence_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(sequence_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:10] 1 2 3 4 5 6 7 8 9 10\n```\n\n\n:::\n:::\n\n\nThe somewhat cryptic output from this command indicates the basic data type found in this vector - in this case `int`, integer; an indication of the number of things in the vector - actually, the indexes of the vector, in this case `[1:10]`; and a few examples of what's actually in the vector - in this case ascending integers.\n\n#### Naming vectors\n\nFinally, you can give names to elements in your vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_example <- 5:8\nnames(my_example) <- c(\"a\", \"b\", \"c\", \"d\")\nmy_example\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d \n5 6 7 8 \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(my_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n:::\n\n\n[Find out more about vectors](https://r4ds.had.co.nz/vectors.html)\n\n### Matrices\n\n> Matrices are 2 dimensional arrays\n\nThe lengths of each dimension are defined by the number of rows and columns.\n\nWe can declare a matrix full of zeros:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_example <- matrix(0, ncol = 6, nrow = 3)\nmatrix_example\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    0    0    0    0    0    0\n[2,]    0    0    0    0    0    0\n[3,]    0    0    0    0    0    0\n```\n\n\n:::\n:::\n\n\nWe can get the number of dimensions of a matrix (or of any array with dimensions \\> 1) and their length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(matrix_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6\n```\n\n\n:::\n:::\n\n\n## Lists\n\n> **Lists can store objects of any data type and class**\n\nAnother key data structure is the `list`. List are the **most flexible data structure** because each element can hold any object, of any data type and dimension, including other lists.\n\nCreate lists using `list()` or coerce other objects using `as.list()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1, \"a\", TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas.list(1:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 4\n```\n\n\n:::\n:::\n\n\nWe can name list elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_list <- list(title = \"Numbers\", numbers = 1:10, data = TRUE)\na_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$title\n[1] \"Numbers\"\n\n$numbers\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$data\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nLists are a base type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(a_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n## Data.frames\n\n### S3, S4 and S6 objects\n\nArrays and lists are all immutable base types. However, there are other types of objects in R.\n\nThese are S3, S4 & S6 type objects, with S3 being the most common.\n\nSuch objects have **a class attribute** (base types can have a class attribute too), enabling class specific functionality, a characteristic of object oriented programming. New classes can be created by users, allowing greater flexibility in the types of data structures available for analyses.\n\n[Learn more about object types](https://adv-r.hadley.nz/base-types.html)\n\n### Data.frames\n\n> **The most important S3 object class in R is the data.frame**.\n>\n> **Data.frames are special types of lists.**\n\nData.frames are **used to store tabular data** and are special types of lists where **each element is a vector**, **each of equal length**. So each column of a data.frame contains values of consistent data type but the data type can vary between columns (i.e. along rows).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  id = 1:3,\n  treatment = c(\"a\", \"b\", \"b\"),\n  complete = c(TRUE, TRUE, FALSE)\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id treatment complete\n1  1         a     TRUE\n2  2         b     TRUE\n3  3         b    FALSE\n```\n\n\n:::\n:::\n\n\nWe can check that our data.frame is a list under the hood:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nAs an S3 object, it also has a class attribute:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\nWe can check the dimensions of a data.frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 3\n```\n\n\n:::\n:::\n\n\nGet a certain number of rows from the top or bottom\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(df, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id treatment complete\n1  1         a     TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(df, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id treatment complete\n3  3         b    FALSE\n```\n\n\n:::\n:::\n\n\nImportantly, we can display the structure of a data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  3 variables:\n $ id       : int  1 2 3\n $ treatment: chr  \"a\" \"b\" \"b\"\n $ complete : logi  TRUE TRUE FALSE\n```\n\n\n:::\n:::\n\n\n### A note on factors\n\nNote that the default behaviour of `data.frame()` USED TO BE to covert character vectors to factors (this default changed as of R 4.0.0). Factors are another important data structure for handling categorical data, which have particular statistical properties. They can be useful during modelling and plotting but in the interest of time we will not be discuss them further here.\n\nYou can suppress R default behaviour using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  id = 1:3,\n  treatment = c(\"a\", \"b\", \"b\"),\n  complete = c(TRUE, TRUE, FALSE),\n  stringsAsFactors = FALSE\n)\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  3 variables:\n $ id       : int  1 2 3\n $ treatment: chr  \"a\" \"b\" \"b\"\n $ complete : logi  TRUE TRUE FALSE\n```\n\n\n:::\n:::\n\n\n[Find out more about factors.](https://r4ds.had.co.nz/factors.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}