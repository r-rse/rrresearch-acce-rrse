{
  "hash": "e3c4aa9339405215b402c9eeadbbda01",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Packaging functionality\"\n---\n\n\n## R Package Structure\n\nUsed to share functionality with the R community\n\n-   Useful **conventions**\n\n-   Useful **software development tools**\n\n-   Easy **publishing** through GitHub\n\n## R Package conventions:\n\n-   **metadata**: in the **`DESCRIPTION` file**\n\n-   **functions** in **`.R` scripts** in the **`R/` folder**\n\n-   **tests** in the **`tests/` folder**\n\n-   **Documentation:**\n\n    -   *functions* using **Roxygen notation**\n    -   *workflows* using **`.Rmd` documents** in the **`vignettes/`** folder\n\n## Software Engineering approach\n\nFollowing conventions allows us to **make use of automated tools** for:\n\n-   **Checking** and **testing code**\n\n-   **Producing documentation** for code and workflows\n\n-   **Publishing, distributing** and **citing** code\n\n\n\n## Anatomy of an R package\n\nLet's use [`pkgreviewr`](https://github.com/ropensci-org/pkgreviewr), a package I authored to help automate some aspects of the rOpenSci review process, as an example to examine some elements of what makes a package:\n\n## `DESCRIPTION` file\n\nCapture metadata around the package - Functionality description - Creators - License\n\n```         \nPackage: pkgreviewr\nType: Package\nTitle: rOpenSci package review project template\nVersion: 0.1.1\nAuthors@R: c(person(\"Anna\", \"Krystalli\", email = \"annakrystalli@googlemail.com\",\n                  role = c(\"aut\", \"cre\")),\n             person(\"Maëlle\", \"Salmon\", email = \"maelle.salmon@yahoo.se\", role = \"aut\"))\nDescription: Creates files and collects materials necessary to complete an rOpenSci package review. \n    Review files are prepopulated with review package specific metadata. Review package source code is\n    also cloned for local testing and inspection.\nLicense: GPL-3 + file LICENSE\nURL: https://github.com/ropenscilabs/pkgreviewr\nBugReports: https://github.com/ropenscilabs/pkgreviewr/issues\nEncoding: UTF-8\nLazyData: true\nImports:\n    devtools,\n    git2r (>= 0.23.0),\n    usethis (>= 1.2.0),\n    here,\n    reprex,\n    gh,\n    base64enc,\n    whoami,\n    magrittr,\n    covr,\n    goodpractice,\n    assertthat,\n    httr,\n    rstudioapi,\n    clipr,\n    clisymbols,\n    crayon,\n    dplyr,\n    glue,\n    fs,\n    urltools,\n    shiny\nSuggests: \n    testthat,\n    mockery,\n    knitr,\n    rmarkdown\nRoxygenNote: 6.1.1\nRemotes: \n    ropensci/git2r\nVignetteBuilder: knitr\nRoxygen: list(markdown = TRUE)\n```\n\n### citation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncitation(\"pkgreviewr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTo cite package 'pkgreviewr' in publications use:\n\n  Krystalli A, Salmon M (2021). _pkgreviewr: rOpenSci package review\n  project template_. R package version 0.3.1,\n  <https://github.com/ropensci-org/pkgreviewr>.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {pkgreviewr: rOpenSci package review project template},\n    author = {Anna Krystalli and Maëlle Salmon},\n    year = {2021},\n    note = {R package version 0.3.1},\n    url = {https://github.com/ropensci-org/pkgreviewr},\n  }\n```\n\n\n:::\n:::\n\n\n## Dependency management\n\nIt’s the job of the DESCRIPTION to **list the packages that your package needs to work**.\n\n```         \nImports:\n    devtools,\n    git2r (>= 0.23.0),\n    usethis (>= 1.2.0),\n    here,\n    reprex,\n    gh,\n    base64enc,\n    whoami,\n    magrittr,\n    covr,\n    goodpractice,\n    assertthat,\n    httr,\n    rstudioapi,\n    clipr,\n    clisymbols,\n    crayon,\n    dplyr,\n    glue,\n    fs,\n    urltools,\n    shiny\n```\n\nImports are necessary dependencies for the functions in your package to work\n\n```         \nSuggests: \n    testthat,\n    mockery,\n    knitr,\n    rmarkdown\n```\n\nSuggests are dependencies that are not necessary for the functions in your package but might be neccessary to run all the vignettes or tests in your package\n\n## `R/`\n\n-   Keep all functions in R scripts in `R/` folder\n\n```         \n.\n├── github.R\n├── pkgreview.R\n├── pkgreviewr-package.R\n├── render-templates.R\n├── rmd-utils.R\n├── style.R\n└── utils.R\n\n0 directories, 7 files\n```\n\n### example function script\n\nCreate a new function `.R` file in the `R/` folder\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(usethis)\nuse_r(\"add\")\n```\n:::\n\n\n```         \nR\n└── add.R\n\n0 directories, 1 files\n```\n\n## Document functions with `Roxygen`\n\n-   Document functions with **Roxygen** notation\n-   Automatically create help files on build\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Add together two numbers.\n#'\n#' @param x A number.\n#' @param y A number.\n#' @return The sum of x and y.\n#' @examples\n#' add(1, 1)\n#' add(10, 1)\nadd <- function(x, y) {\n  x + y\n}\n```\n:::\n\n\n## `tests/`\n\nTests provide confidence in what the code is doing.\n\n*Contents of `pkgreviewr` test folder*\n\n```         \n.\n├── testthat\n│   ├── setup.R\n│   ├── test-create-pkgreview.R\n│   ├── test-gh-calls.R\n│   ├── test-render-templates.R\n│   └── test-setup.R\n└── testthat.R\n\n1 directory, 6 files\n```\n\n### Example test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_test(\"add\")\n```\n:::\n\n\n```         \ntests\n├── testthat\n│   ├── test-add.R\n└── testthat.R\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"add works\", {\n  expect_equal(add(2, 2), 4)\n})\n```\n:::\n\n\nThe **R package structure** can help with providing a logical organisation of files, by **providing a set of standard locations for certain types of files**.\n\nTo work with packages in RStudio we use the **Build pane**, which includes a variety of tools for **building, documenting and testing packages**. This will appear if Rstudio recognises the project as an R package.\n\n![](assets/build-panel.png)\n\n\n\n# :computer: Create your first package\n\n\n::: {.callout-tip collapse=\"true\"}\n## Creating a new package locally\n\nTo create a new package, you can follow the steps for creating any new project, but this time select **`R package`** instead of `New Project` and call your new package `mypackage`.\n\n::: {.alert .alert-info}\n<strong>File \\> New Project... \\> New Directory \\> R package \\> mypackage </strong>\n:::\n\nOtherwise, you can **use function `usethis::create_package(\"mypackage\")`** to create a new package. The argument we provide is the path to here we want our new package created, the **last element being the package name**. Note that there are [restrictions on what characters can be used in a package name](https://r-pkgs.org/workflows101.html#naming).\n:::\n\n\n## Copy **`mypackage`** Project\n\nTo make things easier, I've gone ahead and **set up the basic contents of a new package in project `mypackage`.**\n\nIn our shared space click on the {{< fa plus-square >}} copy button next to the **mypackage** Project to copy it.\n\n![](assets/copy-pkgdev-proj.png)\n\nYour new project should have the following structure.\n\n```         \n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n└── project.Rproj\n```\n\n\n\n\n\n## Initialise git and commit files.\n\nLet's **also configure git again, initialise our project as a git repository and commit our initial files**. We'll need to configure git again as this is a new Posit Cloud project.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# configure git\nusethis::use_git_config(\n  user.name = \"Jane\",\n  user.email = \"jane@example.org\"\n)\n# intialise git and commit\nusethis::use_git()\n```\n:::\n\n\n\n```         \n✔ Setting active project to '/cloud/project/mypackage'\n✔ Initialising Git repo\n✔ Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 5 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'DESCRIPTION'\n* 'mypackage.Rproj'\n* 'NAMESPACE'\nIs it ok to commit them?\n\n1: No way\n2: Nope\n3: I agree\n\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n```\n\n# :vertical_traffic_light: Functions in the **`R/`** dir\n\n## Create function script and first function\n\nLet's create a script and write our first function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_r(\"hello\")\n```\n:::\n\n\n```         \n• Modify 'R/hello.R'\n```\n\n![](assets/r_hello.png)\n\nIn the opened `hello.R` script, let's write our first function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhello <- function() {\n  print(\"Hello, world!\")\n}\n```\n:::\n\n\nIt's a function that takes no arguments and prints `Hello, world!` to the console when called.\n\n## Install package.\n\nYou can install a package locally from it's source code with function `devtools::install()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install()\n```\n:::\n\n\n```         \n── R CMD build ────────────────────────────────────────────\n✔  checking for file ‘/cloud/project/mypackage/DESCRIPTION’ ...\n─  preparing ‘mypackage’:\n✔  checking DESCRIPTION meta-information\n─  checking for LF line-endings in source and make files and shell scripts\n─  checking for empty or unneeded directories\n─  building ‘mypackage_0.0.0.9000.tar.gz’\n   Warning: invalid uid value replaced by that for user 'nobody'\n   \nRunning /opt/R/4.3.3/lib/R/bin/R CMD INSTALL \\\n  /tmp/RtmpVJXWXx/mypackage_0.0.0.9000.tar.gz \\\n  --install-tests \n* installing to library ‘/cloud/lib/x86_64-pc-linux-gnu-library/4.3’\n* installing *source* package ‘mypackage’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (mypackage)\n```\n\nOr click on **{{< fa hammer >}} Install** on the Build panel\n\n![](assets/rsc_build-package.png)\n\n\n## Load library\n\nYou can now load it like any other package...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"mypackage\")\n```\n:::\n\n\n## Try using function\n\nLet's try using our function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhello()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in hello(): could not find function \"hello\"\n```\n\n\n:::\n:::\n\n\nOooops? Our function doesn't seem to be available! :thinking:\n\n\n\n::: {.cell}\n\n:::\n\n\n\nLet's try something else:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmypackage:::hello()\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, world!\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nSo what's happened here? \n\nAlthough the package contains our function, **we have not exported it** to make it available to a user. \n\nCurrently **it is contained as an internal function**. Hence **we can access it with the notation for internal functions (`:::`)** but not directly when we load the package!\n\nTo export the function, **we will need to add a tag to tell R to do so** using a special documentation notation called **Roxygen**!\n\n------------------------------------------------------------------------\n\n# :vertical_traffic_light: Add Roxygen documentation\n\n[`Roxygen2`](http://r-pkgs.had.co.nz/man.html) allows you to write specially-structured comments preceding each function definition to document:\n\n-   a description of what it does\n-   the inputs and outputs\n-   an example of how to use it\n-   **whether to export the function or treat it as internal**\n\nThese are **processed automatically to produce `.Rd` help files** for your functions and **control which functions are exported to the package `NAMESPACE`**.\n\nLet's document our example function.\n\n## Insert Roxygen skeleton\n\nYou can **insert a Roxygen skeleton** by placing the cursor within a function and clicking:\n\n> **Code \\> Insert Roxygen Skeleton**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Title\n#'\n#' @return\n#' @export\n#'\n#' @examples\nhello <- function() {\n  print(\"Hello, world!\")\n}\n```\n:::\n\n\n## Roxygen basics\n\n-   `roxygen` notation indicated by **beginning line with `#'`**.\n\n-   **First line** will be the **title** for the function.\n\n-   After title, include a blank `#'` line and then write a **longer description.**\n\n-   `@param argument_name` **description of the argument.**\n\n-   `@return` description of **what the function returns.**\n\n-   `@export` tells `Roxygen2` to **add this function to the `NAMESPACE`** file, so that it will be **accessible to users.**\n\n-   `@examples` allows to include example of how to use a function\n\n## Complete Roxygen documentation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Hello World!\n#'\n#' Print hello greeting\n#' @return prints hello greeting to console\n#' @export\n#'\n#' @examples\n#' hello()\nhello <- function() {\n  print(\"Hello, world!\")\n}\n```\n:::\n\n\n## Autogenerate documentation\n\nTo auto-generate documentation:\n- **use function `devtools::document()`** or \n- click on **{{< fa cog >}} More > Document**\n\n![](assets/build-document.png)\n```\nℹ Updating mypackage documentation\nℹ Loading mypackage\nWriting 'hello.Rd'\nWriting 'NAMESPACE'\nDocumentation completed\n```\n\nThis re-creates a `hello.Rd` help file in the `man/` folder and populates the `NAMESPACE` with our functions\n\n\n::: callout-tip\n\n### Configure Build Tools\n\nWe can also configure our Build Tools to **run `devtools::document()` every time we re-install the package**. \n\nTo do so, we click on the **Build \\> Configure Build Tools > Generate documentation with Roxygen >  [Configure...](){.btn .btn-outline-primary}** and then tick the **Install and Restart** box.\n\n![](assets/build-doc_config.png)\n\n\nNow clicking {{< fa hammer >}} **Install** in the Build panel will also build your docs in the `man/` folder for you.\n\n\n:::\n\nNow that the documentation has been built, the help file for our `hello()` function is now available!\n\n![](assets/roxygen-done.png)\n\n\n# :vertical_traffic_light: Personalise function\n\nLet's go a step further and **customise our function so that the greeting is from ourselves!**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Hello World!\n#'\n#' Print hello greeting\n#' @return prints hello greeting to console from me\n#' @export\n#'\n#' @examples\n#' hello()\nhello <- function() {\n  print(\"Hello, world from Anna\")\n}\n```\n:::\n\n\n## Add some fun!\n\nProgramming is most useful for having fun. So **let's make our function extra fun!**\n\nWe'll use package `cowsay`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"cowsay\")\n```\n:::\n\n\nwhich has a single function `say`, which does this...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncowsay::say(\"Say whaaaaaat?\", by = \"shark\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n -------------- \nSay whaaaaaat? \n --------------\n    \\\n      \\\n        \\\n              /\"\"-._\n              .       '-,\n               :          '',\n                ;      *     '.\n                 ' *         () '.\n                   \\               \\\n                    \\      _.---.._ '.\n                    :  .' _.--''-''  \\ ,'\n        .._           '/.'             . ;\n        ; `-.          ,                \\'\n         ;   `,         ;              ._\\\n          ;    \\     _,-'                ''--._\n          :    \\_,-'                          '-._\n          \\ ,-'                       .          '-._\n          .'         __.-'';            \\...,__       '.\n        .'      _,-'        \\              \\   ''--.,__  '\\\n        /    _,--' ;         \\              ;           \\^.}\n        ;_,-' )     \\  )\\      )            ;\n             /       \\/  \\_.,-'             ;\n            /                              ;\n         ,-'  _,-'''-.    ,-.,            ;      PFA\n      ,-' _.-'        \\  /    |/'-._...--'\n     :--``             )/\n  '\n  \n```\n\n\n:::\n:::\n\n\n:stuck_out_tongue_winking_eye:\n\nSo **let's create a function that randomly chooses one of the animals** available in `cowsay` **to deliver the greeting**, and also **allow the user to customise who the recipient of the greeting is**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Hello World!\n#'\n#' Print personalised hello greeting from me.\n#'\n#' @param name character string. Your name!\n#'\n#' @return prints hello greeting to console\n#' @export\n#'\n#' @examples\n#' hello()\n#' hello(\"Lucy Elen\")\nhello <- function(name = NULL) {\n    \n    # create greeting\n    if (is.null(name)){name <- \"world\"}\n    greeting <- paste(\"Hello\", name, \"from Anna!\")\n\n    # randomly sample an animal\n    animal_names <- names(cowsay::animals)\n    i <- sample(1:length(animal_names), 1)\n\n    cowsay::say(greeting, animal_names[i])\n}\n```\n:::\n\n\nDocument, Install and restart to load our changes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhello(\"y'all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n ----- \nHello y'all from Anna! \n ------ \n    \\   \n     \\\n      ( )_( )\n      (='.'=)\n      (^)_(^) [nosig]\n  \n```\n\n\n:::\n:::\n\n\nLet's **commit our current files and changes.**\n\n# :vertical_traffic_light: Check package integrity\n\nAn **important part of the package development process is `R CMD check`**. `R CMD check` automatically **checks your code** and can **automatically detects many common problems** that we'd otherwise discover the hard way.\n\nTo check our package, we can:\n\n-   use `devtools::check()`\n\n-   press Ctrl/Cmd + Shift + E\n\n-   click on the :check:**Check** tab in the **Build** panel.\n\nThis:\n\n-   **Ensures that the documentation is up-to-date** by running `devtools::document()`.\n\n-   **Bundles the package** before checking it.\n\nMore info on [checks](http://r-pkgs.had.co.nz/check.html) here.\n\n<br>\n\nBoth these run `R CMD check` which **return three types of messages**:\n\n-   **ERRORs**: Severe problems that you should fix regardless of whether or not you’re submitting to CRAN.\n\n-   **WARNINGs**: Likely problems that you must fix if you’re planning to submit to CRAN (and a good idea to look into even if you’re not).\n\n-   **NOTEs**: Mild problems. If you are submitting to CRAN, you should strive to eliminate all NOTEs, even if they are false positives.\n\nLet's **Check** our package:\n\nClick on the **Check** button (:clipboard: :white_check_mark:)\n\n```         \n   \n── R CMD check results ────────────────────────────── mypackage 0.0.0.9000  ────\nDuration: 8.4s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    What license is it under?\n  Standardizable: FALSE\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' import not declared from: ‘cowsay’\n\n0 errors ✔ | 2 warnings ✖ | 0 notes ✔\nError: R CMD check found WARNINGs\nExecution halted\n\nExited with status 1.\n```\n\nAha, so our checks have thrown up some warnings! First, it's telling us we haven't added a `LICENSE`. It's also telling us that we have a dependency (import) from package `cowsay` which we haven't documented in the `DESCRIPTION` file. `usethis` to the rescue!\n\n## :vertical_traffic_light: Add dependencies\n\nAdd `cowsay` as a dependency.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_package(\"cowsay\")\n```\n:::\n\n\n```         \n✔ Setting active project to '/cloud/project'\n✔ Adding 'cowsay' to Imports field in DESCRIPTION\n• Refer to functions with `cowsay::fun()`\n```\n\n## Add License\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_mit_license(\"Anna Krystalli\")\n```\n:::\n\n\n```\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n```\n\n![](assets/clear-checks.png)\n\nCheck again...All should be good!\n\n```         \n── R CMD check results ─ mypackage 0.0.0.9000 ────\nDuration: 8s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nR CMD check succeeded\n```\n\n#### {{< fa square-check >}} Let's commit our current files and changes.\n\n------------------------------------------------------------------------\n\n# :vertical_traffic_light: Add Test\n\n**Testing is a vital part of package development**. It ensures that our code does what you want it to do.\n\nOnce you're set up with a testing framework, the workflow is simple:\n\n1.  Modify your code or tests.\n\n2.  Test your package with Ctrl/Cmd + Shift + T or `devtools::test()`.\n\n3.  Repeat until all tests pass.\n\n## Create test file\n\nTo create a new test file (and the testing framework if required), use function `usethis::use_test()`. It's good practice to name the test files after the `.R` files containing the functions being tested.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_test(\"hello\")\n```\n:::\n\n\n``` r\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n✔ Writing 'tests/testthat/test-hello.R'\n• Modify 'tests/testthat/test-hello.R'\n```\n\nThis just created the following folders and files\n\n```         \ntests\n├── testthat\n│   └── test-hello.R\n└── testthat.R\n\n1 directory, 2 files\n```\n\nIt also added `testthat` to the suggested packages in the `DESCRIPTION` file.\n\n```         \nSuggests: \n    testthat\n```\n\nThat's because you don't need test that to run the functions in `mypackage`, but you do if you want to run the tests.\n\nWhen the tests are run (either through running `devtools::test()`, clicking on **More \\> Test Package** in the Build panel or `Cmd/Ctrl + Shift + T`), the code in each test script in directory `testthat` is run.\n\n## **`test-hello.R`**\n\nLet's load the library so we can explore the `testthat` testing framework\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTest passed 🎉\n```\n\n\n:::\n:::\n\n\nIf the test doesn't pass it throws an error\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 5)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n── Failure: multiplication works ───────────────────────────────────────────────\n2 * 2 not equal to 5.\n1/1 mismatches\n[1] 4 - 5 == -1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! Test failed\n```\n\n\n:::\n:::\n\n\n## Write test\n\nLet's **write a simple test to check that we are getting an expected output type**. \n\nOne way to **test the consistency of the output of a function**, especially one that may output messages, warnings etc, like ours does, is to **use `expect_snapshot()`**. \n\nThis function takes a snapshot of the output of a function and compares it to the snapshot the next time the test is run.\n\nNow, because our functions has a random element to it (selecting a random animal), we need to **set the seed** to ensure that the output is consistent across runs.\n\nSo let'sr eplace the placeholder testing code and add a snapshot test each for:\n\n- the function's default behaviour.\n- the function's behaviour when a `name` is provided.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"hello works\", {\n  set.seed(1)\n  expect_snapshot(hello())\n  expect_snapshot(hello(\"Lucy Elen\"))\n})\n```\n:::\n\n\nNow let's test our package\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::test()\n```\n:::\n\n\nThe first time we run our tests, `testthat` will create a snapshot of the output of our function and warns us of that. The next time we run the tests, it will compare the output of the function to the snapshot and let us know if it has changed.\n\n\nIf you run your tests twice you should have success!\n\n```         \n==> devtools::test()\n\nℹ Testing mypackage\n✔ | F W  S  OK | Context\n✔ |          2 | hello                            \n\n══ Results ═══════════════════════════════════════\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n```\n\n#### {{< fa square-check >}} Let's commit our current files and changes.\n\n# :vertical_traffic_light: Create README\n\nThe final document you will need for your package is a `README`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_readme_rmd()\n```\n:::\n\n\n```         \n✔ Setting active project to '/cloud/project'\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n• Modify 'README.Rmd'\n• Update 'README.Rmd' to include installation instructions.\n✔ Writing '.git/hooks/pre-commit'\n```\n\n`.Rmd` documents are the predecessors to Quarto documents and allow us to run R code in our GitHub README.\n\nBecause it's an `.Rmd` but GitHub can only display an `md` document as it's landing page, this is a **special `.Rmd` that renders to a markdown document rather than `html`**. \n\nThe function adds a check to `.git` to ensure you commit an up to date version on the `md` when you commit changes to the `.Rmd`.\n\nImportant elements of a README to include:\n\n- **Installation instructions:** In our case we will be distributing our package via GitHub, so we will include instructions on how to install the package from GitHub using `remotes::install_github(\"<yourgithubusername>/mypackage\")`.\n- **Description:** A brief description of what the package does.\n- **Examples:** A few simple examples of how to use the package.\n\nComplete the README. Here's what mine looks like:\n\n\n````\n---\noutput: github_document\n---\n\n<!-- README.md is generated from README.Rmd. Please edit that file -->\n\n\n\n# mypackage\n\n<!-- badges: start -->\n<!-- badges: end -->\n\nThe goal of mypackage is to print a personalised greeting from me!\n\n## Installation\n\nYou can install the development version of mypackage from GitHub with:\n\n``` r\n# install.packages(\"remotes\")\nremotes::install_github(\"annakrystalli/mypackage\")\n```\n\n## Example\n\nThis is a basic example which shows you how to print a generic greeting:\n\n```{{r example}}\nlibrary(mypackage)\n## basic example code\nhello()\n```\n\nThis is a basic example which shows you how to print a personalised greeting:\n\n```{{r}}\nhello(name = \"Lucy Elen\")\n```\n\n````\n\nand renders to the following when **Knit**\n\n![](assets/rendered-pkg-readme.png)\n\n\n#### {{< fa square-check >}} Let's commit our current files and changes.\n\n# :vertical_traffic_light: Complete package metadata\n\nLet's head to the `DESCRIPTION` file and complete the details.\n\n## Authors\n\nFirst let's complete the authors. \n\nRemove the current author and maintainer lines and replace it with the following line:\n\n```         \nAuthors@R: person(\"First\", \"Last\", email = \"first.last@example.com\", role = c(\"aut\", \"cre\"))\n```\n\ncompleted with your own details\n\n## Add a title and description\n\n**Complete the title and description fields with appropriate details.**\n\nIf you want to form a paragraph of text, make sure do indent the hanging lines by 4 spaces (one tab). And make sure that your Description field **ends in a full-stop**.\n\n## Add a date\n\nUse today's date in ISO format, ie **2024-04-19**. This will populate a citation entry for us.\n\n### Completed `DESCRIPTION`\n\nThe complete `DESCRIPTION` file should look something like this:\n\n```         \nPackage: mypackage\nTitle: Customised greetings from me!\nVersion: 0.0.0.9000\nAuthors@R: person(\"Anna\", \"Krystalli\", \n  email = \"annakrystalli@googlemail.com\", \n  role = c(\"aut\", \"cre\"))\nDescription: Prints a customised greeting from myself,\n  delivered by a friend.\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.1\nImports: \n    cowsay\nSuggests: \n    testthat (>= 3.0.0)\nConfig/testthat/edition: 3\nDate: 2024-04-19\n```\n\nCheck your package. If all is good, document, install and restart!\n\nNow, check you're package's citation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncitation(\"mypackage\")\n```\n:::\n\n\n```         \nTo cite package ‘mypackage’ in publications use:\n\n  Krystalli A (2024). _mypackage: Customised\n  greetings from me!_. R package version 0.0.0.9000.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {mypackage: Customised greetings from me!},\n    author = {Anna Krystalli},\n    year = {2024},\n    note = {R package version 0.0.0.9000},\n  }\n```\n\n#### {{< fa square-check >}} Let's commit our current files and changes.\n\n## Create GitHub repo and push to GitHub\n\nNow you have everything you need to share your package on GitHub so create a GitHub repository and push our local content up to it.\n\n_You will need to set your PAT through `credentials` again in this new project._\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# configure GitHub PAT credentials\ncredentials::set_github_pat()\n\n# create GitHub repository and push\nusethis::use_github(protocol = \"https\")\n```\n:::\n\n\n```\n✔ Creating GitHub repository 'annakrystalli/mypackage'\n✔ Setting remote 'origin' to 'https://github.com/annakrystalli/mypackage.git'\n✔ Adding 'https://github.com/annakrystalli/mypackage' to URL\n✔ Adding 'https://github.com/annakrystalli/mypackage/issues' to BugReports\nThere is 1 uncommitted file:\n* 'DESCRIPTION'\nIs it ok to commit it?\n\n1: Absolutely\n2: Not now\n3: No way\n\nSelection: 1\n✔ Adding files\n✔ Making a commit with message 'Add GitHub links to DESCRIPTION'\n✔ Pushing 'master' branch to GitHub and setting 'origin/master' as upstream branch\n✔ Opening URL 'https://github.com/annakrystalli/mypackage'\n```\n\nThis will **create a new GitHub repository** and **push the contents of your package to it**. \n\nBefore doing so it also adds details of our remote to the `DESCRIPTION` file and commits it.\n\nNow anyone will be able to install my package using, eg:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"annakrystalli/mypackage\")\n```\n:::\n\n\nAdd the link to your package repo in the [hackpad](http://bit.ly/acce24-hackpad). \n\n**Visit someone else's package repo, follow the instructions to install, load it and receive a personalised greeting from the author!**\n\n# Setup Continuous Integration with GitHub Actions\n\n## Continuous Integration Background\n\nContinuous integration (CI) is the practice of automating the integration of code changes from multiple contributors into a single software project. Automated tools are used to assert the new code’s correctness before integration. In our case this is what are tests are for. And GitHub Actions allows us to do this all within GitHub!\n\nOnce the appropriate CI workflow is set up, **it will automatically run our tests for us every time we push new code to GitHub or when a new pull request is made**. This way we can (try to) **ensure we don't merge new code into our code base that introduces bugs** (causing our tests to fail). \n\n**Obviously, our ability to screen for breaking changes is only as good as our tests!** But at least we can get GitHub to run our tests for us!\n\n## Setup R CMD CHECK GitHub Action\n\nTo run CI workflows through GitHub Actions, we specify the actions or jobs we want the CI system in a `.yaml` file that lives in `.github/workflows/` folder in the root of our package/project. \n\nThis can be quite complicated for complex projects as you have to **effectively specify instructions for GitHub to recreate a computational environment to run the tests in**. The `.yaml` format can also be fiddly, with indents having special meaning. \n\nHowever for a standard R project like ours, there is a `usethis` functions that can create and appropriate `.yaml` for us that works right out of the box!\n\nLet's try it out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_github_action(\"check-standard\")\n```\n:::\n\n\n```         \n✔ Creating '.github/'\n✔ Adding '^\\\\.github$' to '.Rbuildignore'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/check-standard.yaml@v2' to '.github/workflows/R-CMD-check.yaml'\n• Learn more at <https://github.com/r-lib/actions/blob/v2/examples/README.md>.\n✔ Adding R-CMD-check badge to 'README.Rmd'\n• Re-knit 'README.Rmd' with `devtools::build_readme()`\n```\n\nThis workflow installs the latest release of R on macOS and runs R CMD check via the `rcmdcheck` package.\n\n\n\n```{.yaml .cell-code}\n# Workflow derived from https://github.com/r-lib/actions/tree/master/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n\nname: R-CMD-check\n\njobs:\n  R-CMD-check:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n    steps:\n      - uses: actions/checkout@v2\n\n      - uses: r-lib/actions/setup-r@v1\n        with:\n          use-public-rspm: true\n\n      - uses: r-lib/actions/setup-r-dependencies@v1\n        with:\n          extra-packages: rcmdcheck\n\n      - uses: r-lib/actions/check-r-package@v1\n\n      - name: Show testthat output\n        if: always()\n        run: find check -name 'testthat.Rout*' -exec cat '{}' \\; || true\n        shell: bash\n\n      - name: Upload check results\n        if: failure()\n        uses: actions/upload-artifact@main\n        with:\n          name: ${{ runner.os }}-r${{ matrix.config.r }}-results\n          path: check\n```\n\n\n-   Re-knit `README.Rmd` to include GitHub Actions badge.\n-   Commit the whole `.github` folder as well as `README.Rmd` & `README.md`\n-   Push to GitHub\n\n#### {{< fa square-check >}} Let's commit our current files and changes and push to GitHub.\n_You'll need your GitHub PAT again_\n\n\nThis will activate the `R-CMD-CHECK` GitHub Actions workflow and begin running it.\n\nTo see details and the status of GitHub Actions workflows, click on the {{< fa play-circle >}} **Actions** tab and select the workflow to view. \n\n![](assets/ga-actions-running.png)\n\nIf our test passes, the run will show as successful :white_check_mark: and so will the badge in our README. If there are any problems, error messages will appear in the logs.\n\n\n![](assets/ga-r-cmd-check-success.png)\n\n\n\n# :vertical_traffic_light: Create documentation site\n\nWhile the README is a great first step for documenting your package, there is an easy way to create a full website which makes the documentation of each exported function avaliable online and where you could include additional, more detailed vignettes.\n\nYou can use package `pkgdown` to create an online site for your documentation. It effectively recycles the documentation you have already created for your functions, information in your README and DESCRIPTION file and presents it in a standardised website form.\n\nLet's set up our package with such a site.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_pkgdown()\n```\n:::\n\n\n```\n✔ Setting active project to '/cloud/project'\n✔ Adding '^_pkgdown\\\\.yml$', '^docs$', '^pkgdown$' to '.Rbuildignore'\n✔ Adding 'docs' to '.gitignore'\n✔ Writing '_pkgdown.yml'\n• Modify '_pkgdown.yml'\n```\n\nAnd now let's build it the site.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npkgdown::build_site()\n```\n:::\n\n\n```         \n-- Installing package into temporary library --------------\n== Building pkgdown site =======================================================\nReading from: '/cloud/project'\nWriting to:   '/cloud/project/docs'\n-- Initialising site -----------------------------------------------------------\nCopying '../lib/x86_64-pc-linux-gnu-library/4.3/pkgdown/BS5/assets/link.svg' to 'link.svg'\nCopying '../lib/x86_64-pc-linux-gnu-library/4.3/pkgdown/BS5/assets/pkgdown.js' to 'pkgdown.js'\n-- Building home ---------------------------------------------------------------\nWriting 'authors.html'\nReading 'LICENSE.md'\nWriting 'LICENSE.html'\nWriting 'LICENSE-text.html'\nWriting '404.html'\n-- Building function reference -------------------------------------------------\nWriting 'reference/index.html'\nReading 'man/hello.Rd'\nWriting 'reference/hello.html'\nWriting 'sitemap.xml'\n-- Building search index -------------------------------------------------------\n== DONE ========================================================================\n-- Previewing site ----------------------------------------\n```\n\nThis creates html documentation for our package in the `docs/` folder and presents you with a preview to the site.\n\n::: callout-caution\n_Note the Preview might be blocked in Posit Cloud and when you click to allow a pop might still look a bit wonky!_\n:::\n\nNow, you could push this `docs/` folder to GitHub and serve through GitHub Pages, but **you would need to rebuild, commit and push these docs any time there was a change in the package documentation**.\n\nInstead what we could do is **get our CI system (GitHub Actions) to build our docs for us automatically every time there is a push or pull request to our repository!!** So let's try this approach!\n\nIndeed that's what the `usethis::use_pkgdown()` workflow expects so **has already told git to ignore local copies of the docs in our `docs/` folder by adding `docs/*` to our `.gitignore` file**. This way, we can still build and preview our site locally if we want but we won't commit it to our`master` or `main` branch.\n\nThen, we can deploy another GitHub Actions template, provided by `usethis` that again will work right out the box!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_github_action(\"pkgdown\")\n```\n:::\n\n\n```         \n✔ Saving 'r-lib/actions/examples/pkgdown.yaml@v2' to '.github/workflows/pkgdown.yaml'\n• Learn more at <https://github.com/r-lib/actions/blob/v2/examples/README.md>.\n```\n\nThis creates another file in `.github/workflows/` called `pkgdown.yaml`. The workflow installs the package, building all documentation, installs `pkgdown` and uses it to build the site. It then commits the build site to a separate `gh-pages` site.\n\n\n\n```{.r .cell-code}\n# Workflow derived from https://github.com/r-lib/actions/tree/master/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\non:\n  push:\n    branches: [main, master]\n  release:\n    types: [published]\n  workflow_dispatch:\n\nname: pkgdown\n\njobs:\n  pkgdown:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n    steps:\n      - uses: actions/checkout@v2\n\n      - uses: r-lib/actions/setup-pandoc@v1\n\n      - uses: r-lib/actions/setup-r@v1\n        with:\n          use-public-rspm: true\n\n      - uses: r-lib/actions/setup-r-dependencies@v1\n        with:\n          extra-packages: pkgdown\n          needs: website\n\n      - name: Deploy package\n        run: |\n          git config --local user.name \"$GITHUB_ACTOR\"\n          git config --local user.email \"$GITHUB_ACTOR@users.noreply.github.com\"\n          Rscript -e 'pkgdown::deploy_to_branch(new_process = FALSE)'\n```\n\n\nCommit the file and push it up to GitHub to activate. Once the workflow completes successfully, you will find the html for your documentation for you site in a new `gh-pages` branch!\n\n#### {{< fa square-check >}} Let's commit our current files and changes.\n\n## Enable `gh-pages`\n\nTo **serve our new site**, we need to **enable GitHub Pages and set the source directory to the root of the `gh-pages` branch.**\n\nWe can use function `usethis::use_github_pages()` to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_github_pages()\n```\n:::\n\n\n```\n✔ Activating GitHub Pages for 'annakrystalli/mypackage'\n✔ GitHub Pages is publishing from:\n• URL: 'http://annakrystalli.me/mypackage/'\n• Branch: 'gh-pages'\n• Path: '/'\n```\n\n\n\nTo check our Github Pages settings we go to {{< fa cog >}} **Settings** and click on **Pages** on the navigation bar on the left. \n\nAlso Double Check that **Enforce HTTPS is checked at the bottom**.\n\n![](assets/enforce-https.png)\n\n## Check site\n\nYou'll find your site at the URL provided in the GitHub Pages settings. \n\n![](assets/mypackage-site.png)\n\nYou can add it to your repo details by clicking on the **{{< fa cog >}} in the About side panel** and ticking **Use your Github Pages website**.\n\n![](assets/add-pages-to-about.png)\n\n\nCheck out my complete example [here](https://github.com/annakrystalli/mypackage-demo)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}