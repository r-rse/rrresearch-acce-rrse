{
  "hash": "8206a16a0629b1e0b4259d3a996710ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Joining Data\"\nsubtitle: \"Data Munging\"\n---\n\n::: {.cell}\n\n:::\n\n\n\nLet's say **our analysis requires that we can geolocate every individual in our analytic data**. \n\nAs we've discussed, the various tables we downloaded hold different information collected during the various survey events.\n\n- Plot level metadata\n- Individual level tagging metadata\n- Individual level repeated measurement data (although we only have a single measurement event per individual in our data set).\n\n**Currently, only the plot is geolocated**, the data being **contained in `vst_perplotperyear.csv` columns `decimalLatitude` and `decimalLongitude`.** \n\nThe **location of each individual stem is defined in `vst_mappingandtagging.csv`.** \n\nA **number of variables are involved**, including:\n\n- **`pointID`** which identifies **a point on a 10m cell grid centred around `decimalLatitude` and `decimalLongitude`** \n- **`stemDistance` and `stemAzimuth`** which define the **location of a stem, relative to the location of `pointID`**. The full method used to locate individual stems is detailed in `data-raw/wood-survey-data-master/methods/NEON_vegStructure_userGuide_vA.pdf`. \n\n::: {.callout-note collapse=\"true\"}\n## Browse `NEON_vegStructure_userGuide_vA.pdf` \n\n\n::: {.cell}\n<iframe src=\"data-raw/wood-survey-data-master/methods/NEON_vegStructure_userGuide_vA.pdf\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](assets/NEON_point_grid.png){width=346}\n:::\n:::\n\n\nSo, **to geolocate our individuals, we need to join information from `vst_perplotperyear.csv` and `vst_mappingandtagging.csv` into our `individual` tibble.**\n\nWe use the **family of `*_join` functions** in `dplyr` to merge columns from different tibbles according to values in shared columns.\n\n\n\n## Join Basics\n\nThere are a **number of joins we can perform with `dplyr`.**\n\nLet's have a look at a few of them with a simple example using some `dplyr` in-built data:\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  band   \n  <chr> <chr>  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n```\n\n\n:::\n\n```{.r .cell-code}\nband_instruments\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  plays \n  <chr> <chr> \n1 John  guitar\n2 Paul  bass  \n3 Keith guitar\n```\n\n\n:::\n:::\n\n\nThe **only variable shared between the two tables is `name` so this is the only variable we can perform joins over**. By default, any `*_join` function will try to merge on the values of any matched columns in the tables being merged.\n\n### Inner joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members %>% inner_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(name)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n```\n\n\n:::\n:::\n\n\n**`inner_join`** has merged all three unique columns across the two tables into a single tibble.\nIt has only kept the rows in which **`name` values had a match in both tables**. In this case only data about `John` and `Paul` was contained in both tables.\n\n### Left joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members %>% left_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(name)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n```\n\n\n:::\n:::\n\n\n`left_join` joins on the `names` in the left hand table and **appends any rows from the right hand table in which values in `name` match**. In this case, there is no data for `Keith` in `band_members` so he is ignored completely. There is also no match for `Mick` in `band_instruments` so `NA` is returned for `plays` instead.\n\n### Right joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members %>% right_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(name)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n3 Keith <NA>    guitar\n```\n\n\n:::\n:::\n\n\n`right_join` on the other hand **joins on the `name` in the right hand table**. In this case, `Mick` is dropped completely `Keith` gets `NA` for band.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members %>% full_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(name)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n4 Keith <NA>    guitar\n```\n\n\n:::\n:::\n\n\nFinally, a `full_join` joins on all unique values of `name` found across the two tables, returning `NA` where there are no matches between the two tables.\n\n## Joining our tables with `dplyr`\n\n## Join `vst_mappingandtagging.csv` data\n\nLet's start by merging data from `vst_mappingandtagging.csv`. Let's read the data in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaptag <- readr::read_csv(\n  fs::path(raw_data_path, \"vst_mappingandtagging.csv\")\n)\n```\n:::\n\n\nThis data set contains **taxonomic and within-plot location metadata on individuals** collected during mapping and tagging. There is **one row per individual** in the data set.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(maptag)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"uid\"            \"eventID\"        \"pointID\"        \"stemDistance\"  \n[5] \"stemAzimuth\"    \"individualID\"   \"taxonID\"        \"scientificName\"\n[9] \"taxonRank\"     \n```\n\n\n:::\n:::\n\n\nLet's see how many matches in column names we have between the two datasets\n\n##### Challenge: Finding column name matches in two tables\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Given the two tables we are trying to join, can you write some code that checks which column names in `individual` have matches in `maptag` column names?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(individual)[names(individual) %in% names(maptag)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"uid\"          \"eventID\"      \"individualID\"\n```\n\n\n:::\n:::\n\n\n:::\n\n#### Default `left_join`\n\nBecause **we want to match the rest of the tables to our individual data, we use `left_join()`** and supply **`individual` as the first argument** and **`maptag` as the second**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  dplyr::left_join(maptag)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(uid, eventID, individualID)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 18\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 10 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>, pointID <dbl>, stemDistance <dbl>,\n#   stemAzimuth <dbl>, taxonID <chr>, scientificName <chr>, taxonRank <chr>\n```\n\n\n:::\n:::\n\n\nGreat we have a merge! \n\nLooks successful right? **How do we really know nothing has gone wrong though?** \n\nRemember, **to successfully merge the tables, the values in the columns the tables are being joined on need to have corresponding values across all join columns to be linked successfully, otherwise it will return `NA`s**. So, although our code ran successfully, it may well not have found any matching rows in `maptag` to merge into `individual`. \n\nTo check whether things have worked, **we can start with inspecting the output for the columns of interest**, in this case the `maptag` columns we are trying to join into `individual`.\n\n::: callout-tip\nWhen working interactively and testing out pipes, you can pipe objects into `View()` for quick inspection. If you provide a character string as an argument, it is used as a name for the data view tab it launches\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  dplyr::left_join(maptag) %>%\n  View(\"default\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](assets/view_default_join.png){width=688}\n:::\n:::\n\n\n\nClearly this has not worked! We need to start digging into why but **we don't want to have to keep manually checking whether it worked** or not. Enter **DEFENSIVE PROGRAMMING**.\n\n\n## Defensive programming with data\n\nAs I mentioned in the Data Management Basics slides, **[`assertr`](https://github.com/ropensci/assertr) is a useful package for including validation checks in our data pipelines.**\n\nIn our case, **we can use `assertr` function `assert` to check that certain columns of interest (`stemDistance`, `stemAzimuth`, `pointID`) are joined successfully (i.e. they contain no `NA` values)**. \n\n::: callout-caution\n\nNote that *this only works because I know for a fact that there is data available for all individuals*. There **may be situations in which `NA`s are valid missing data, in which case this would not be an appropriate test.**\n\n:::\n\nLet's introduce this check into our pipeline:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  dplyr::left_join(maptag) %>%\n  assertr::assert(assertr::not_na, stemDistance, stemAzimuth, pointID)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(uid, eventID, individualID)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nColumn 'stemDistance' violates assertion 'not_na' 14961 times\n    verb redux_fn predicate       column index value\n1 assert       NA    not_na stemDistance     1    NA\n2 assert       NA    not_na stemDistance     2    NA\n3 assert       NA    not_na stemDistance     3    NA\n4 assert       NA    not_na stemDistance     4    NA\n5 assert       NA    not_na stemDistance     5    NA\n  [omitted 14956 rows]\n\n\nColumn 'stemAzimuth' violates assertion 'not_na' 14961 times\n    verb redux_fn predicate      column index value\n1 assert       NA    not_na stemAzimuth     1    NA\n2 assert       NA    not_na stemAzimuth     2    NA\n3 assert       NA    not_na stemAzimuth     3    NA\n4 assert       NA    not_na stemAzimuth     4    NA\n5 assert       NA    not_na stemAzimuth     5    NA\n  [omitted 14956 rows]\n\n\nColumn 'pointID' violates assertion 'not_na' 14961 times\n    verb redux_fn predicate  column index value\n1 assert       NA    not_na pointID     1    NA\n2 assert       NA    not_na pointID     2    NA\n3 assert       NA    not_na pointID     3    NA\n4 assert       NA    not_na pointID     4    NA\n5 assert       NA    not_na pointID     5    NA\n  [omitted 14956 rows]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError: assertr stopped execution\n```\n\n\n:::\n:::\n\n\nThe `assertr::assert` function applies the predicate `assertr::not_na` on columns `stemDistance`, `stemAzimuth`, `pointID` which checks that each column does not contain `NA` values. \n\nBy appending it onto our pipeline, the function will through an error if the predicate assertion returns `FALSE` in any of the columns `stemDistance`, `stemAzimuth`, `pointID`. If the assertion is `TRUE`, the pipeline will continue as expected.\n\n**By including this check, I don't have to guess or manually check whether the merge has been successful. The code will just error if it hasn't** :raised_hands:. \n\n## Debugging hidden mismatches:\n\nI've shown **the most minimal implementation in which `dplyr` does a lot of the guessing for us and tries to join on all matched columns**. But often, that can generate table mismatches \n\n**We know that the only column we are interested in matching on is `individualID`**. We want to get the mapping associated with each individual, regardless of when the mapping was collected. \n\n**Let's be specific about which variables we want to join on through argument `by`.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  dplyr::left_join(maptag,\n    by = \"individualID\"\n  ) %>%\n  assertr::assert(assertr::not_na, stemDistance, stemAzimuth, pointID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 20\n   uid.x  namedLocation date       eventID.x domainID siteID plotID individualID\n   <chr>  <chr>         <date>     <chr>     <chr>    <chr>  <chr>  <chr>       \n 1 a36a1… BART_037.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7… BART_037.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 5 2a447… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 6 e4852… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 7 280c9… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 8 0e506… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n 9 4918c… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n10 ef16c… BART_044.bas… 2015-08-26 vst_BART… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 12 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>, uid.y <chr>, eventID.y <chr>,\n#   pointID <dbl>, stemDistance <dbl>, stemAzimuth <dbl>, taxonID <chr>,\n#   scientificName <chr>, taxonRank <chr>\n```\n\n\n:::\n:::\n\n\n\n**Excellent! Our code runs and our resulting merged tibble contains data for all the variables we are interested in!**\n\nHowever, on closer inspection, **we've ended up with some odd new columns, `uid.x` and `uid.y` and `eventID.x` and `eventID.y`!**\n\nThat's because **those columns are also present in both our tables but we are not explicitly joining them**. They are retained and each suffixed with `.x` & `.y` by default, to make them unique. \n\nSo, what about these duplicate columns. Do we need them?\n\n### Dropping unnecessary columns\n\nWith respect to `eventID`, **we're not really interested in the mapping `eventID`s so we can just drop that column from  `maptag`.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaptag <- select(maptag, -eventID)\n\nindividual %>%\n  dplyr::left_join(maptag,\n    by = \"individualID\"\n  ) %>%\n  assertr::assert(assertr::not_na, stemDistance, stemAzimuth, pointID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 19\n   uid.x    namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 11 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>, uid.y <chr>, pointID <dbl>,\n#   stemDistance <dbl>, stemAzimuth <dbl>, taxonID <chr>, scientificName <chr>,\n#   taxonRank <chr>\n```\n\n\n:::\n:::\n\n\n### Retaining useful metadata\n\nOn the other hand, **`\"uid` contains unique identifiers for each observation in their respective table and could be useful metadata to store**, enabling us to trace the provenance of individual values to the original data. So rather than remove them, let's retain both `uid`, one for each table.\n\n**We can give more informative suffixes using argument `suffix`**. In our case, I want the `individual` column to stay as `uid` and the `maptag` column to get the suffix `_map`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %>%\n  dplyr::left_join(maptag,\n    by = \"individualID\",\n    suffix = c(\"\", \"_map\")\n  ) %>%\n  assertr::assert(assertr::not_na, stemDistance, stemAzimuth, pointID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 19\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 11 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>, uid_map <chr>, pointID <dbl>,\n#   stemDistance <dbl>, stemAzimuth <dbl>, taxonID <chr>, scientificName <chr>,\n#   taxonRank <chr>\n```\n\n\n:::\n:::\n\n\nNice!\n\n\n## Join `vst_perplotperyear.csv`\n\nNow let's carry on and **join the perplot data**. \n\nFirst let's read it in and have a look at the data. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperplot <- readr::read_csv(\n  fs::path(raw_data_path, \"vst_perplotperyear.csv\"),\n  show_col_types = FALSE)\n\nperplot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 184 × 13\n   uid                plotID plotType nlcdClass decimalLatitude decimalLongitude\n   <chr>              <chr>  <chr>    <chr>               <dbl>            <dbl>\n 1 93ee1436-cdd8-40b… BART_… distrib… deciduou…            44.0            -71.3\n 2 4b5f972f-d00f-476… BART_… distrib… deciduou…            44.1            -71.3\n 3 66594b70-4db4-400… BART_… distrib… deciduou…            44.1            -71.3\n 4 730098e8-30a7-4b7… BART_… distrib… mixedFor…            44.0            -71.3\n 5 07c96abe-6d78-481… BART_… distrib… deciduou…            44.1            -71.3\n 6 557410ec-351d-434… BART_… distrib… mixedFor…            44.1            -71.3\n 7 afc50622-9684-4d6… BART_… distrib… deciduou…            44.0            -71.3\n 8 6d597101-9c98-4ba… BART_… distrib… deciduou…            44.0            -71.3\n 9 591a2808-5add-407… BART_… distrib… mixedFor…            44.0            -71.3\n10 12dbf09b-5f23-4ab… BART_… distrib… mixedFor…            44.1            -71.3\n# ℹ 174 more rows\n# ℹ 7 more variables: geodeticDatum <chr>, easting <dbl>, northing <dbl>,\n#   utmZone <chr>, elevation <dbl>, elevationUncertainty <dbl>, eventID <chr>\n```\n\n\n:::\n:::\n\n\nSimilarly to `maptag`, **we want to exclude `eventID` and suffix the `uid` column**. This time, however, we will be joining by `plotID`**\n\nLet's also **move our validation test to the end and add additional columns from `perplot` we want to check to it**, i.e. `stemDistance`, `stemAzimuth`, `pointID`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperplot <- perplot %>% select(-eventID)\n\nindividual %>%\n  dplyr::left_join(maptag,\n    by = \"individualID\",\n    suffix = c(\"\", \"_map\")\n  ) %>%\n  dplyr::left_join(perplot,\n    by = c(\"plotID\"),\n    suffix = c(\"\", \"_ppl\")\n  ) %>%\n  assertr::assert(\n    assertr::not_na, decimalLatitude,\n    decimalLongitude, plotID, stemDistance, stemAzimuth, pointID\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,961 × 30\n   uid      namedLocation date       eventID domainID siteID plotID individualID\n   <chr>    <chr>         <date>     <chr>   <chr>    <chr>  <chr>  <chr>       \n 1 a36a162… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 2 68dc7ad… BART_037.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 3 a8951ab… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 4 eb348ea… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 5 2a4478e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 6 e485203… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 7 280c904… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 8 0e5060e… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n 9 4918cac… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n10 ef16cb9… BART_044.bas… 2015-08-26 vst_BA… D01      BART   BART_… NEON.PLA.D0…\n# ℹ 14,951 more rows\n# ℹ 22 more variables: growthForm <chr>, stemDiameter <dbl>,\n#   measurementHeight <dbl>, height <dbl>, uid_map <chr>, pointID <dbl>,\n#   stemDistance <dbl>, stemAzimuth <dbl>, taxonID <chr>, scientificName <chr>,\n#   taxonRank <chr>, uid_ppl <chr>, plotType <chr>, nlcdClass <chr>,\n#   decimalLatitude <dbl>, decimalLongitude <dbl>, geodeticDatum <chr>,\n#   easting <dbl>, northing <dbl>, utmZone <chr>, elevation <dbl>, …\n```\n\n\n:::\n:::\n\n\nAwesome!! It's worked! :tada:\n\n## Using the assignment pipe\n\nNow that we are happy with our data we can use a new operator, the **assignment pipe (`%<>%`)**.\n\n**This allows us to both pipe an object forward into an expression and also update it with the resulting value.**\n\n::: callout-caution\nNote that this operator can have unexpected results if you run the same code multiple times in an interactive session. Use it in scripts that will be run from top to bottom only once.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividual %<>%\n  dplyr::left_join(maptag,\n    by = \"individualID\",\n    suffix = c(\"\", \"_map\")\n  ) %>%\n  dplyr::left_join(perplot,\n    by = c(\"plotID\"),\n    suffix = c(\"\", \"_ppl\")\n  ) %>%\n  assertr::assert(\n    assertr::not_na, decimalLatitude,\n    decimalLongitude, plotID, stemDistance, stemAzimuth, pointID\n  )\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n## Update `individual.R`\n\nLet's **update our `individual.R` script again with the additional code we've just written for reading in and merging the `maptag` and `perplot` data**.\n\nAdd the following code and comments to `individual.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine NEON data tables ----\n# read in additional tables\nmaptag <- readr::read_csv(\n  fs::path(\n    raw_data_path,\n    \"vst_mappingandtagging.csv\"\n  ),\n  show_col_types = FALSE\n) %>%\n  select(-eventID)\n\nperplot <- readr::read_csv(\n  fs::path(\n    raw_data_path,\n    \"vst_perplotperyear.csv\"\n  ),\n  show_col_types = FALSE\n) %>%\n  select(-eventID)\n\n# Left join tables to individual\nindividual %<>%\n  left_join(maptag,\n    by = \"individualID\",\n    suffix = c(\"\", \"_map\")\n  ) %>%\n  left_join(perplot,\n    by = \"plotID\",\n    suffix = c(\"\", \"_ppl\")\n  ) %>%\n  assertr::assert(\n    assertr::not_na, stemDistance, stemAzimuth, pointID,\n    decimalLongitude, decimalLatitude, plotID\n  )\n```\n:::\n\n\n\n\n***\n\n\n\n\nWe can now move on to geolocate our individuals!\n\n\n\n::: {.cell}\n<iframe src=\"assets/cheatsheets/data-transformation.pdf\" width=\"672\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n",
    "supporting": [
      "03b_dplyr_joins_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}